/* File: object2.c */

/*
 * Copyright (c) 1997 Ben Harrison, James E. Wilson, Robert A. Koeneke
 * 						Jeff Greene, Diego Gonzalez
 *
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */

#include "angband.h"





/*
 * Choose an object kind that seems "appropriate" to the given level
 *
 * This function uses the "prob2" field of the "object allocation table",
 * and various local information, to calculate the "prob3" field of the
 * same table, which is then used to choose an "appropriate" object, in
 * a relatively efficient manner.
 *
 * It is (slightly) more likely to acquire an object of the given level
 * than one of a lower level.  This is done by choosing several objects
 * appropriate to the given level and keeping the "hardest" one.
 *
 * Note that if no objects are "appropriate", then this function will
 * fail, and return zero, but this should *almost* never happen.
 * (but it does happen with certain themed items occasionally). -JG
 */
s16b get_obj_num(int level)
{
	int i, j, p;

	int k_idx;

	long value, total;

	object_kind *k_ptr;

	alloc_entry *table = alloc_kind_table;

	/* Boost level */
	if (level > 0)
	{
		/* Occasional "boost" */
		if (one_in_(GREAT_OBJ))
		{
			/* What a bizarre calculation */
			level = 1 + (level * MAX_DEPTH    / randint(MAX_DEPTH));
		}
	}

	/* Reset total */
	total = 0L;

	/* Process probabilities */
	for (i = 0; i < alloc_kind_size; i++)
	{
		/* Objects are sorted by depth */
		if (table[i].level > level) break;

		/* Default */
		table[i].prob3 = 0;

		/* Get the index */
		k_idx = table[i].index;

		/* Get the actual kind */
		k_ptr = &k_info[k_idx];

		/* Hack -- prevent embedded chests, but allow them for quests*/
		if ((object_generation_mode == OB_GEN_MODE_CHEST)
			    && (k_ptr->tval == TV_CHEST)) continue;

		/* Accept */
		table[i].prob3 = table[i].prob2;

		/* Total */
		total += table[i].prob3;
	}

	/* No legal objects */
	if (total <= 0) return (0);

	/* Pick an object */
	value = rand_int(total);

	/* Find the object */
	for (i = 0; i < alloc_kind_size; i++)
	{
		/* Found the entry */
		if (value < table[i].prob3) break;

		/* Decrement */
		value = value - table[i].prob3;
	}


	/* Power boost */
	p = rand_int(100);

	/* Try for a "better" object once (50%) or twice (10%) */
	if (p < 60)
	{
		/* Save old */
		j = i;

		/* Pick a object */
		value = rand_int(total);

		/* Find the monster */
		for (i = 0; i < alloc_kind_size; i++)
		{
			/* Found the entry */
			if (value < table[i].prob3) break;

			/* Decrement */
			value = value - table[i].prob3;
		}

		/* Keep the "best" one */
		if (table[i].level < table[j].level) i = j;
	}

	/* Try for a "better" object twice (10%) */
	if (p < 10)
	{
		/* Save old */
		j = i;

		/* Pick a object */
		value = rand_int(total);

		/* Find the object */
		for (i = 0; i < alloc_kind_size; i++)
		{
			/* Found the entry */
			if (value < table[i].prob3) break;

			/* Decrement */
			value = value - table[i].prob3;
		}

		/* Keep the "best" one */
		if (table[i].level < table[j].level) i = j;
	}


	/* Result */
	return (table[i].index);
}


/*
 *
 * These attributes include tohit, todam, toac, cost, and pval (charges).
 *
 * Note that "knowing" an object gives you everything that an "awareness"
 * gives you, and much more.  In fact, the player is always "aware" of any
 * item which he "knows", except items in stores.
 *
 * But having full knowledge of, say, one "wand of wonder", does not, by
 * itself, give you knowledge, or even awareness, of other "wands of wonder".
 * It happens that most "identify" routines (including "buying from a shop")
 * will make the player "aware" of the object as well as "know" it.
 *
 * This routine also removes any inscriptions generated by "feelings".
 */
void object_known(object_type *o_ptr)
{
	/* Remove special inscription, if any */
	if (o_ptr->discount >= INSCRIP_NULL) o_ptr->discount = 0;

	/* The object is not "sensed" */
	o_ptr->ident &= ~(IDENT_SENSE);

	/* Clear the "Empty" info */
	o_ptr->ident &= ~(IDENT_EMPTY);

	/* Now we know about the item */
	o_ptr->ident |= (IDENT_KNOWN);
}



/*
 * The player is now aware of the effects of the given object.
 */
void object_aware(object_type *o_ptr)
{
	int x, y;
	bool flag = k_info[o_ptr->k_idx].aware;

 	/* Fully aware of the effects */
 	k_info[o_ptr->k_idx].aware = TRUE;


	/* MEGA-HACK - scrolls can change the graphics when becoming aware */
	if (o_ptr->tval == TV_SCROLL)
	{
		/* Redraw map */
		p_ptr->redraw |= (PR_MAP);

	}

	/* If newly aware and squelched, must rearrange stacks */
	if ((!flag) && (k_info[o_ptr->k_idx].squelch == SQUELCH_ALWAYS))
	{
		for (x = 0; x < p_ptr->cur_map_wid; x++)
		{
			for (y = 0; y < p_ptr->cur_map_hgt; y++)
			{
				rearrange_stack(y, x);
			}
		}
	}
}



/*
 * Something has been "sampled"
 */
void object_tried(object_type *o_ptr)
{
	/* Mark it as tried (even if "aware") */
	k_info[o_ptr->k_idx].tried = TRUE;
}






/*
 * Prepare an object based on an object kind.
 */
void object_prep(object_type *o_ptr, int k_idx)
{
	object_kind *k_ptr = &k_info[k_idx];

	/* Clear the record */
	(void)WIPE(o_ptr, object_type);

	/* Save the kind index */
	o_ptr->k_idx = k_idx;

	/* Efficiency -- tval/sval */
	o_ptr->tval = k_ptr->tval;
	o_ptr->sval = k_ptr->sval;

	/* Default "pval" */
	o_ptr->pval = k_ptr->pval;

	/* Default number */
	o_ptr->number = 1;

	/* Default weight */
	o_ptr->weight = k_ptr->weight;

	/* Default magic */
	o_ptr->to_h = k_ptr->to_h;
	o_ptr->to_d = k_ptr->to_d;
	o_ptr->to_a = k_ptr->to_a;

	/* Default power */
	o_ptr->ac = k_ptr->ac;
	o_ptr->dd = k_ptr->dd;
	o_ptr->ds = k_ptr->ds;

	/* Hack -- worthless items are always "broken" */
	if (k_ptr->cost <= 0) o_ptr->ident |= (IDENT_BROKEN);

	/* Hack -- cursed items are always "cursed" */
	if (k_ptr->k_flags3 & (TR3_LIGHT_CURSE)) o_ptr->ident |= (IDENT_CURSED);
	if (k_ptr->k_flags3 & (TR3_HEAVY_CURSE)) o_ptr->ident |= (IDENT_CURSED);
	if (k_ptr->k_flags3 & (TR3_PERMA_CURSE)) o_ptr->ident |= (IDENT_CURSED);

	/* Hack -- extract the perfect_balance flag */
	if (k_ptr->k_flags3 & (TR3_PERFECT_BALANCE)) o_ptr->ident |= (IDENT_PERFECT_BALANCE);
}





/*
 * Cheat -- describe a created object for the user
 */
static void object_mention(const object_type *o_ptr)
{
	char o_name[80];

	/* Describe */
	object_desc_spoil(o_name, sizeof(o_name), o_ptr, FALSE, 0);

	/* Artifact */
	if (artifact_p(o_ptr))
	{
		/* Silly message */
		msg_format("Artifact (%s)", o_name);
	}

	/* Ego-item */
	else if (ego_item_p(o_ptr))
	{
		/* Silly message */
		msg_format("Ego-item (%s)", o_name);
	}

	/* Normal item */
	else
	{
		/* Silly message */
		msg_format("Object (%s)", o_name);
	}
}


/*
 * Attempt to change an object into an ego-item -MWK-
 * Better only called by apply_magic().
 * The return value says if we picked a cursed item (if allowed) and is
 * passed on to a_m_aux1/2().
 * If no legal ego item is found, this routine returns 0, resulting in
 * an unenchanted item.
 */
static int make_ego_item(object_type *o_ptr, bool only_good, bool only_great)
{
	int i, j, level;

	int e_idx;

	long value, total;

	ego_item_type *e_ptr;

	alloc_entry *table = alloc_ego_table;

	/* Fail if object already is ego or artifact */
	if (o_ptr->art_num) return (FALSE);
	if (o_ptr->ego_num) return (FALSE);

	level = object_level;

	/* Boost level (like with object base types) */
	if (level > 0)
	{
		/* Occasional "boost" */
		if (one_in_(GREAT_EGO))
		{
			/* The bizarre calculation again */
			level = 1 + (level * MAX_DEPTH / randint(MAX_DEPTH));
		}
	}

	/* Reset total */
	total = 0L;

	/* Process probabilities */
	for (i = 0; i < alloc_ego_size; i++)
	{
		/* Default */
		table[i].prob3 = 0;

		/* Objects are sorted by depth */
		if (table[i].level > level) continue;

		/* Get the index */
		e_idx = table[i].index;

		/* Get the actual kind */
		e_ptr = &e_info[e_idx];

		/* If we force good/great, don't create cursed */
		if (only_good && (e_ptr->flags3 & TR3_LIGHT_CURSE)) continue;

		/* Test if this is a legal ego-item type for this object */
		for (j = 0; j < EGO_TVALS_MAX; j++)
		{
			/* Require identical base type */
			if (o_ptr->tval == e_ptr->tval[j])
			{
				/* Require sval in bounds, lower */
				if (o_ptr->sval >= e_ptr->min_sval[j])
				{
					/* Require sval in bounds, upper */
					if (o_ptr->sval <= e_ptr->max_sval[j])
					{
						/* Accept */
						table[i].prob3 = table[i].prob2;
					}
				}
			}
		}

		/* Total */
		total += table[i].prob3;
	}

	/* No ego-item types for this object (example: books in non-ironman mode) */
	if (total == 0) return (0);

	/*enforce a true rarity if there are only one or a few rare ego items*/
	if ((randint(100) > total) && (!only_great)) return (0);

	/* Pick an ego-item */
	value = rand_int(total);

	/* Find the object */
	for (i = 0; i < alloc_ego_size; i++)
	{
		/* Found the entry */
		if (value < table[i].prob3) break;

		/* Decrement */
		value = value - table[i].prob3;
	}

	/* We have one */
	e_idx = (byte)table[i].index;
	o_ptr->ego_num = e_idx;

	return ((e_info[e_idx].flags3 & TR3_LIGHT_CURSE) ? -2 : 2);
}


/*
 * Mega-Hack -- Attempt to create one of the "Special Objects".
 *
 * We are only called from "make_object()", and we assume that
 * "apply_magic()" is called immediately after we return.
 *
 * Note -- see "make_artifact()" and "apply_magic()".
 *
 * We *prefer* to create the special artifacts in order, but this is
 * normally outweighed by the "rarity" rolls for those artifacts.  The
 * only major effect of this logic is that the Phial (with rarity one)
 * is always the first special artifact created.
 */
static bool make_artifact_special(object_type *o_ptr)
{
	int i;

	int k_idx;

	int depth_check = ((object_generation_mode) ?  object_level : effective_depth(p_ptr->depth));

	/*no artifacts while making items for stores*/
	if ((object_generation_mode >= OB_GEN_STORE_HEAD) &&
		(object_generation_mode <= OB_GEN_STORE_TAIL)) return (FALSE);

	/*no special artifacts as quest rewards */
	if (object_generation_mode == OB_GEN_MODE_QUEST) return (FALSE);

	/* No artifacts, do nothing */
	if (adult_no_artifacts) return (FALSE);

	/* No artifacts in the town, unless opening a chest or creating chest item */
	if (!depth_check) return (FALSE);

	/* Check the special artifacts */
	for (i = 0; i < z_info->art_spec_max; ++i)
	{
		artifact_type *a_ptr = &a_info[i];

		/* Skip "empty" artifacts */
		if (a_ptr->tval + a_ptr->sval == 0) continue;

		/* Cannot make an artifact twice */
		if (a_ptr->a_cur_num) continue;

		/*Hack - don't allow cursed artifacts as quest items*/
		if (object_generation_mode == OB_GEN_MODE_QUEST)
		{
			if (a_ptr->a_flags3 & (TR3_LIGHT_CURSE)) continue;
			if (a_ptr->a_flags3 & (TR3_HEAVY_CURSE)) continue;
			if (a_ptr->a_flags3 & (TR3_PERMA_CURSE)) continue;
		}

		/* Enforce minimum "depth" (loosely) */
		if (a_ptr->a_level > depth_check)
		{
			/* Get the "out-of-depth factor" */
			int d = (a_ptr->a_level - depth_check) * 2;

			/* Roll for out-of-depth creation */
			if (rand_int(d) != 0) continue;
		}

		/* Artifact "rarity roll" */
		if (rand_int(a_ptr->a_rarity) != 0) continue;

		/* Find the base object */
		k_idx = lookup_kind(a_ptr->tval, a_ptr->sval);

		/* Enforce minimum "object" level (loosely) */
		if (k_info[k_idx].k_level > depth_check)
		{
			/* Get the "out-of-depth factor" */
			int d = (k_info[k_idx].k_level - depth_check) * 5;

			/* Roll for out-of-depth creation */
			if (rand_int(d) != 0) continue;
		}

		/* Assign the template */
		object_prep(o_ptr, k_idx);

		/* Mark the item as an artifact */
		o_ptr->art_num = i;

		/* Success */
		return (TRUE);
	}

	/* Failure */
	return (FALSE);
}


/*
 * Attempt to change an object into an artifact
 *
 * This routine should only be called by "apply_magic()"
 *
 * Note -- see "make_artifact_special()" and "apply_magic()"
 */
static bool make_artifact(object_type *o_ptr)
{
	int i;

	int depth_check = ((object_generation_mode) ?  object_level : effective_depth(p_ptr->depth));

	/*no artifacts while making items for stores, this is a double-precaution*/
	if ((object_generation_mode >= OB_GEN_MODE_GEN_ST) &&
		(object_generation_mode <= OB_GEN_MODE_BOOKSHOP)) return (FALSE);

	/* No artifacts, do nothing */
	if (adult_no_artifacts) return (FALSE);

	/* No artifacts in the town, unless opening a chest or creating chest item */
	if (!depth_check) return (FALSE);

	/* First try to create a randart, if allowed */
	if ((can_be_randart(o_ptr)) && (!adult_no_xtra_artifacts))
	{
		int chance = depth_check;

		/* Hack - harder for quest objects because so many of them are generated */
		if (object_generation_mode == OB_GEN_MODE_QUEST) if (chance < 20) chance = 20;

		chance += (MAX_DEPTH + depth_check) / 10;

		/*occasionally make a randart*/
		if(one_in_(chance))
		{
			/*artifact power is based on depth*/
			int randart_power = 20 + (depth_check * 6 / 5);

			/*occasional power boost*/
			while (one_in_(25)) randart_power += 35;

			/*
			 * Make a randart.  This should always succeed, unless
			 * there is no space for another randart
		     */
			if (make_one_randart(o_ptr, randart_power, FALSE)) return (TRUE);
		}
	}

	/* Paranoia -- no "plural" artifacts */
	if (o_ptr->number != 1) return (FALSE);

	/* Check the artifact list (skip the "specials" and randoms) */
	for (i = z_info->art_spec_max; i < z_info->art_norm_max; i++)
	{
		artifact_type *a_ptr = &a_info[i];

		/* Skip "empty" items */
		if (a_ptr->tval + a_ptr->sval == 0) continue;

		/* Cannot make an artifact twice */
		if (a_ptr->a_cur_num) continue;

		/* Must have the correct fields */
		if (a_ptr->tval != o_ptr->tval) continue;
		if (a_ptr->sval != o_ptr->sval) continue;

		/*Hack - don't allow cursed artifacts as quest items*/
		if (object_generation_mode == OB_GEN_MODE_QUEST)
		{
			if (a_ptr->a_flags3 & (TR3_LIGHT_CURSE)) continue;
			if (a_ptr->a_flags3 & (TR3_HEAVY_CURSE)) continue;
			if (a_ptr->a_flags3 & (TR3_PERMA_CURSE)) continue;
		}

		/* XXX XXX Enforce minimum "depth" (loosely) */
		if (a_ptr->a_level > depth_check)
		{
			/* Get the "out-of-depth factor" */
			int d = (a_ptr->a_level - depth_check) * 2;

			/* Roll for out-of-depth creation */
			if (rand_int(d) != 0) continue;
		}

		/* We must make the "rarity roll" */
		if (!one_in_(a_ptr->a_rarity)) continue;

		/* Mark the item as an artifact */
		o_ptr->art_num = i;

		/* Success */
		return (TRUE);
	}

	/* Failure */
	return (FALSE);
}


/*
 * Charge a new wand.
 */
s16b charge_wand(object_type *o_ptr, int percent)
{
	s16b pval = 0;

	switch (o_ptr->sval)
	{
		case SV_WAND_HEAL_MONSTER:		pval = randint(20) + 8; break;
		case SV_WAND_HASTE_MONSTER:		pval = randint(20) + 8; break;
		case SV_WAND_CLONE_MONSTER:		pval = randint(5)  + 3; break;
		case SV_WAND_TELEPORT_AWAY:		pval = randint(5)  + 6; break;
		case SV_WAND_DISARMING:			pval = randint(5)  + 4; break;
		case SV_WAND_TRAP_DOOR_DEST:	pval = randint(8)  + 6; break;
		case SV_WAND_STONE_TO_MUD:		pval = randint(4)  + 3; break;
		case SV_WAND_LIGHT:				pval = randint(10) + 6; break;
		case SV_WAND_SLEEP_MONSTER:		pval = randint(15) + 8; break;
		case SV_WAND_SLOW_MONSTER:		pval = randint(10) + 6; break;
		case SV_WAND_CONFUSE_MONSTER:	pval = randint(12) + 6; break;
		case SV_WAND_FEAR_MONSTER:		pval = randint(5)  + 3; break;
		case SV_WAND_DRAIN_LIFE:		pval = randint(3)  + 3; break;
		case SV_WAND_POLYMORPH:			pval = randint(8)  + 6; break;
		case SV_WAND_STINKING_CLOUD:	pval = randint(8)  + 6; break;
		case SV_WAND_MAGIC_MISSILE:		pval = randint(10) + 6; break;
		case SV_WAND_ACID_BOLT:			pval = randint(8)  + 6; break;
		case SV_WAND_ELEC_BOLT:			pval = randint(8)  + 6; break;
		case SV_WAND_FIRE_BOLT:			pval = randint(8)  + 6; break;
		case SV_WAND_COLD_BOLT:			pval = randint(5)  + 6; break;
		case SV_WAND_ACID_BALL:			pval = randint(5)  + 2; break;
		case SV_WAND_ELEC_BALL:			pval = randint(8)  + 4; break;
		case SV_WAND_FIRE_BALL:			pval = randint(4)  + 2; break;
		case SV_WAND_COLD_BALL:			pval = randint(6)  + 2; break;
		case SV_WAND_WONDER:			pval = randint(15) + 8; break;
		case SV_WAND_ANNIHILATION:		pval = randint(2)  + 1; break;
		case SV_WAND_DRAGON_FIRE:		pval = randint(3)  + 1; break;
		case SV_WAND_DRAGON_COLD:		pval = randint(3)  + 1; break;
		case SV_WAND_DRAGON_BREATH:		pval = randint(3)  + 1; break;
		case SV_WAND_WALL_BUILDING:		pval = randint(5)  + 3; break;
	}

	/* Apply the proportional amount of charges */
	pval = pval * percent / 100;
	if (pval < 1) pval = 1;

	return (pval);
}



/*
 * Charge a new staff.
 */
s16b charge_staff(object_type *o_ptr, int percent)
{
	s16b pval = 0;

	switch (o_ptr->sval)
	{
		case SV_STAFF_DARKNESS:			pval = randint(8)  + 8; break;
		case SV_STAFF_SLOWNESS:			pval = randint(8)  + 8; break;
		case SV_STAFF_HASTE_MONSTERS:	pval = randint(8)  + 8; break;
		case SV_STAFF_SUMMONING:		pval = randint(3)  + 1; break;
		case SV_STAFF_TELEPORTATION:	pval = randint(4)  + 5; break;
		case SV_STAFF_IDENTIFY:			pval = randint(10) + 10; break;
		case SV_STAFF_STARLIGHT:		pval = randint(5)  + 6; break;
		case SV_STAFF_LIGHT:			pval = randint(20) + 8; break;
		case SV_STAFF_MAPPING:			pval = randint(5)  + 5; break;
		case SV_STAFF_DETECT_GOLD:		pval = randint(20) + 8; break;
		case SV_STAFF_DETECT_ITEM:		pval = randint(15) + 6; break;
		case SV_STAFF_DETECT_TRAP:		pval = randint(5)  + 6; break;
		case SV_STAFF_DETECT_DOOR:		pval = randint(8)  + 6; break;
		case SV_STAFF_DETECT_INVIS:		pval = randint(15) + 8; break;
		case SV_STAFF_DETECT_EVIL:		pval = randint(15) + 8; break;
		case SV_STAFF_CURE_LIGHT:		pval = randint(5)  + 6; break;
		case SV_STAFF_CURING:			pval = randint(3)  + 4; break;
		case SV_STAFF_HEALING:			pval = randint(2)  + 1; break;
		case SV_STAFF_THE_MAGI:			pval = randint(2)  + 2; break;
		case SV_STAFF_SLEEP_MONSTERS:	pval = randint(5)  + 6; break;
		case SV_STAFF_SLOW_MONSTERS:	pval = randint(5)  + 6; break;
		case SV_STAFF_SPEED:			pval = randint(3)  + 4; break;
		case SV_STAFF_PROBING:			pval = randint(6)  + 2; break;
		case SV_STAFF_DISPEL_EVIL:		pval = randint(3)  + 4; break;
		case SV_STAFF_POWER:			pval = randint(3)  + 1; break;
		case SV_STAFF_HOLINESS:			pval = randint(2)  + 2; break;
		case SV_STAFF_BANISHMENT:		pval = randint(2)  + 1; break;
		case SV_STAFF_EARTHQUAKES:		pval = randint(5)  + 3; break;
		case SV_STAFF_DESTRUCTION:		pval = randint(3)  + 1; break;
		case SV_STAFF_MASS_IDENTIFY:	pval = randint(5) + 5; break;
		case SV_STAFF_MASS_POLYMORPH:	pval = randint(5)  + 6; break;
		case SV_STAFF_REMOVE_CURSE:		pval = randint(3)  + 4; break;
	}

	/* Apply the proportional amount of charges */
	pval = pval * percent / 100;
	if (pval < 1) pval = 1;

	return (pval);
}

/*
 *
 * Determines the theme of a chest.  This function is called
 * from chest_death when the chest is being opened. JG
 *
 */
static int choose_chest_contents (void)
{
	int chest_theme; /*the returned chest theme*/

	int minlevel; /*helps keep low level themes from appearing at higher levels*/

	int chestlevel; /* random number which determines type of chest theme*/

	int num; /*number used in random section*/

	/*keep weaker themes out of deeper levels*/
	minlevel = object_level / 4;

	/*Hack - don't wan't results over 100 to keep dragon armor themed chests rare*/
	if ((object_level + minlevel) > 100) num = 100 - minlevel;

	else num = object_level;

	/* Hack - some themes don't work in Moria, and there are fewer levels. Cut it off at 60. */
	if (game_mode == GAME_NPPMORIA)
	{
		if ((object_level + minlevel) > 60) num = 60 - minlevel;

		else num = object_level;
	}

	chestlevel = randint (num) + minlevel;



	/*now determine the chest theme*/

	/* chest theme #1 is treasure, theme 16 is a chest, not used here.  */
	if (chestlevel <= 10) chest_theme = DROP_TYPE_GOLD;

	/*
	 * from 500' to 1100", treasure begins to give way to
	 * potions, rods/wands/staffs, and scrolls all with almost equal chances.
	 * chest theme #16 is reserved generating an actual chest, it shouldn't be returned here
	 *     which returns the object *nothing* while opening a chest.
	 * chest theme #2 is potions  (+ mushroom of restoring)
	 * chest theme #3 is rods/wands/staffs
	 * chest theme #4 is scrolls
	 * with gold, these are the themes up to 1100', where the weapons and
	 * armor gradually begin to take over.
	 * JG
	 */
	else if (chestlevel <=25) chest_theme = (randint (3)) + 1;

	/*
	 * The next nine themes are armor/weapons,
	 * along with the potions, scrolls, and rods, all with equal chances
	 *
	 * chest theme # 5 is shields
	 * chest theme # 6 is weapons
	 * chest theme # 7 is armor (includes dragon armor)
	 * chest theme # 8 is boots
	 * chest theme # 9 is bow
	 * chest theme #10 is cloak
	 * chest theme #11 is gloves
	 * chest theme #12 is hafted weapons (for the priests)
	 * chest theme #13 is headgear (including crowns)
	 * JG
	 */
	else if (chestlevel <=60) chest_theme = (randint (12)) + 1;

 	/*
	 * Now 10 themes are available, with
	 * jewlery (rings of speed, amulets, and crowns) added.
	 * Equal probability for all themes.
	 *
	 * chest theme # 14 is jewelery
	 * JG
	 */

	else if (chestlevel <=99) chest_theme = (randint (10)) + 4;

	/*
	 * If 100, chest theme # 15 is exclusively
	 * dragon armor scale mail.
	 */
	else chest_theme = DROP_TYPE_DRAGON_ARMOR;

	return(chest_theme);
}

/*
 * Apply magic to an item known to be a "weapon"
 *
 * Hack -- note special base to hit and damage dice boosting
 * Hack -- note special processing for weapon/digger
 * Hack -- note special rating boost for dragon scale mail
 */
static void a_m_aux_1(object_type *o_ptr, int level, int power)
{
	int tohit1 = randint(5) + m_bonus(5, level);
	int todam1 = randint(5) + m_bonus(5, level);

	int tohit2 = m_bonus(10, level);
	int todam2 = m_bonus(10, level);


	/* Good */
	if (power > 0)
	{
		/* Enchant */
		o_ptr->to_h += tohit1;
		o_ptr->to_d += todam1;

		/* Very good */
		if (power > 1)
		{
			/* Enchant again */
			o_ptr->to_h += tohit2;
			o_ptr->to_d += todam2;
		}
	}

	/* Cursed */
	else if (power < 0)
	{
		/* Penalize */
		o_ptr->to_h -= tohit1;
		o_ptr->to_d -= todam1;

		/* Very cursed */
		if (power < -1)
		{
			/* Penalize again */
			o_ptr->to_h -= tohit2;
			o_ptr->to_d -= todam2;
		}

		/* Cursed (if "bad") */
		if (o_ptr->to_h + o_ptr->to_d < 0) o_ptr->ident |= (IDENT_CURSED);
	}


	/* Analyze type */
	switch (o_ptr->tval)
	{
		case TV_DIGGING:
		{
			/* Very bad */
			if (power < -1)
			{
				/* Hack -- Horrible digging bonus */
				o_ptr->pval = 0 - (5 + randint(5));
			}

			/* Bad */
			else if (power < 0)
			{
				/* Hack -- Reverse digging bonus */
				o_ptr->pval = 0 - (o_ptr->pval);
			}

			break;
		}

		case TV_HAFTED:
		case TV_POLEARM:
		case TV_SWORD:
		case TV_BOLT:
		case TV_ARROW:
		case TV_SHOT:
		{
			/*average items*/
			int chance = 50;

			if (power < 0) break;

			/* Very Good */
			if (power > 1) 	chance = 15;
			else if (power > 0) chance = 35;

			/* Hack -- Super-charge the damage dice */
			while ((o_ptr->dd * o_ptr->ds > 0) &&
			       (one_in_(chance)))
			{
				o_ptr->dd++;
			}

			/* Hack -- Limit the damage dice to max of 9*/
			if (o_ptr->dd > 9) o_ptr->dd = 9;

			/* Hack -- Super-charge the damage sides */
			while ((o_ptr->dd * o_ptr->ds > 0) &&
			       (one_in_(chance)))
			{
				o_ptr->ds++;
			}

			/* Hack -- Limit the damage dice to max of 9*/
			if (o_ptr->ds > 9) o_ptr->ds = 9;

			break;
		}

	}
}


/*
 * Apply magic to an item known to be "armor"
 *
 * Hack -- note special processing for crown/helm
 * Hack -- note special processing for robe of permanence
 */
static void a_m_aux_2(object_type *o_ptr, int level, int power)
{
	int toac1 = randint(5) + m_bonus(5, level);

	int toac2 = m_bonus(10, level);


	/* Good */
	if (power > 0)
	{
		/* Enchant */
		o_ptr->to_a += toac1;

		/* Very good */
		if (power > 1)
		{
			/* Enchant again */
			o_ptr->to_a += toac2;
		}
	}

	/* Cursed */
	else if (power < 0)
	{
		/* Penalize */
		o_ptr->to_a -= toac1;

		/* Very cursed */
		if (power < -1)
		{
			/* Penalize again */
			o_ptr->to_a -= toac2;
		}

		/* Cursed (if "bad") */
		if (o_ptr->to_a < 0) o_ptr->ident |= (IDENT_CURSED);
	}


	/* Analyze type */
	switch (o_ptr->tval)
	{
		case TV_DRAG_ARMOR:
		case TV_DRAG_SHIELD:
		{
			/* Mention the item */
			if (cheat_peek) object_mention(o_ptr);

			break;
		}
	}
}



/*
 * Apply magic to an item known to be a "ring" or "amulet"
 *
 * Hack -- note special rating boost for ring of speed
 * Hack -- note special rating boost for certain amulets
 * Hack -- note special "pval boost" code for ring of speed
 * Hack -- note that some items must be cursed (or blessed)
 */
static void a_m_aux_3(object_type *o_ptr, int level, int power)
{
	/* Apply magic (good or bad) according to type */
	switch (o_ptr->tval)
	{
		case TV_RING:
		{
			/* Analyze */
			switch (o_ptr->sval)
			{
				/* Strength, Constitution, Dexterity, Intelligence */
				case SV_RING_STR:
				case SV_RING_CON:
				case SV_RING_DEX:
				case SV_RING_INT:
				{
					/* Stat bonus */
					o_ptr->pval = 1 + m_bonus(5 + (level / 35), level);

					/*cut it off at 6*/
					if (o_ptr->pval > 6) o_ptr->pval = 6;

					/* Cursed */
					if (power < 0)
					{
						/* Broken */
						o_ptr->ident |= (IDENT_BROKEN);

						/* Cursed */
						o_ptr->ident |= (IDENT_CURSED);

						/* Reverse pval */
						o_ptr->pval = 0 - (o_ptr->pval);
					}

					break;
				}

				/* Ring of Speed! */
				case SV_RING_SPEED:
				{
					if (game_mode == GAME_NPPMORIA)
					{
						/* Cursed Ring */
						if (power < 0)
						{
							/* Broken */
							o_ptr->ident |= (IDENT_BROKEN);

							/* Cursed */
							o_ptr->ident |= (IDENT_CURSED);

							/* Reverse pval */
							o_ptr->pval = 0 - (o_ptr->pval);
						}
						else
						{
							/* Rating boost for rings of speed that are not cursed */
							rating += 25;

							o_ptr->pval = 1;
						}

						break;
					}

					/* Base speed (1 to 10) */
					o_ptr->pval = randint(5) + m_bonus(5, level);

					/* Super-charge the ring */
					while (one_in_(2)) o_ptr->pval++;

					/* Cursed Ring */
					if (power < 0)
					{
						/* Broken */
						o_ptr->ident |= (IDENT_BROKEN);

						/* Cursed */
						o_ptr->ident |= (IDENT_CURSED);

						/* Reverse pval */
						o_ptr->pval = 0 - (o_ptr->pval);

						break;
					}

					/* Rating boost for rings of speed that are not cursed */
					else rating += 25;

					/* Mention the item */
					if (cheat_peek) object_mention(o_ptr);

					break;
				}

				/* Searching */
				case SV_RING_SEARCHING:
				{
					/* Bonus to searching */
					o_ptr->pval = 1 + m_bonus(5, level);

					/* Cursed */
					if (power < 0)
					{
						/* Broken */
						o_ptr->ident |= (IDENT_BROKEN);

						/* Cursed */
						o_ptr->ident |= (IDENT_CURSED);

						/* Reverse pval */
						o_ptr->pval = 0 - (o_ptr->pval);
					}

					break;
				}

				/* Searching */
				case SV_RING_AGGRAVATION:
				{
					/* Cursed */
					o_ptr->ident |= (IDENT_CURSED);

					break;
				}


				/* Flames, Acid, Ice, Lightning */
				case SV_RING_FLAMES:
				case SV_RING_ACID:
				case SV_RING_ICE:
				case SV_RING_LIGHTNING:
				{
					/* Bonus to armor class */
					o_ptr->to_a = 5 + randint(5) + m_bonus(10, level) + (level / 10);
					break;
				}

				/* Weakness, Stupidity */
				case SV_RING_WEAKNESS:
				case SV_RING_STUPIDITY:
				{
					/* Broken */
					o_ptr->ident |= (IDENT_BROKEN);

					/* Cursed */
					o_ptr->ident |= (IDENT_CURSED);

					/* Penalize */
					o_ptr->pval = 0 - (1 + m_bonus(5, level));

					break;
				}

				/* WOE, Stupidity */
				case SV_RING_WOE:
				{
					/* Broken */
					o_ptr->ident |= (IDENT_BROKEN);

					/* Cursed */
					o_ptr->ident |= (IDENT_CURSED);

					/* Penalize */
					o_ptr->to_a = 0 - (5 + m_bonus(10, level));
					o_ptr->pval = 0 - (1 + m_bonus(5, level));

					break;
				}

				/* Ring of damage */
				case SV_RING_DAMAGE:
				{
					/* Bonus to damage */
					o_ptr->to_d = 5 + randint(3) + m_bonus(7, level) + (level / 10);

					/* Cursed */
					if (power < 0)
					{
						/* Broken */
						o_ptr->ident |= (IDENT_BROKEN);

						/* Cursed */
						o_ptr->ident |= (IDENT_CURSED);

						/* Reverse bonus */
						o_ptr->to_d = 0 - (o_ptr->to_d);
					}

					break;
				}

				/* Ring of Accuracy */
				case SV_RING_ACCURACY:
				{
					/* Bonus to hit */
					o_ptr->to_h = 5 + randint(3) + m_bonus(7, level) + (level / 10);

					/* Cursed */
					if (power < 0)
					{
						/* Broken */
						o_ptr->ident |= (IDENT_BROKEN);

						/* Cursed */
						o_ptr->ident |= (IDENT_CURSED);

						/* Reverse tohit */
						o_ptr->to_h = 0 - (o_ptr->to_h);
					}

					break;
				}

				/* Ring of Protection */
				case SV_RING_PROTECTION:
				{
					/* Bonus to armor class */
					o_ptr->to_a = 5 + randint(5) + m_bonus(10, level) + (level / 5);

					/* Cursed */
					if (power < 0)
					{
						/* Broken */
						o_ptr->ident |= (IDENT_BROKEN);

						/* Cursed */
						o_ptr->ident |= (IDENT_CURSED);

						/* Reverse toac */
						o_ptr->to_a = 0 - (o_ptr->to_a);
					}

					break;
				}

				/* Ring of Slaying */
				case SV_RING_SLAYING:
				{
					/* Bonus to damage and to hit */
					o_ptr->to_d = randint(5) + m_bonus(5, level) + (level / 10);
					o_ptr->to_h = randint(5) + m_bonus(5, level) + (level / 10);

					/* Cursed */
					if (power < 0)
					{
						/* Broken */
						o_ptr->ident |= (IDENT_BROKEN);

						/* Cursed */
						o_ptr->ident |= (IDENT_CURSED);

						/* Reverse bonuses */
						o_ptr->to_h = 0 - (o_ptr->to_h);
						o_ptr->to_d = 0 - (o_ptr->to_d);
					}

					break;
				}
				/* Ring of Slaying */
				case SV_RING_LORD_PROT_ACID:
				case SV_RING_LORD_PROT_FIRE:
				case SV_RING_LORD_PROT_COLD:
				{
					/* Bonus plus to AC */
					o_ptr->to_a = randint(5) + m_bonus(5, level) + (level / 10);

					/* Cursed */
					if (power < 0)
					{
						/* Broken */
						o_ptr->ident |= (IDENT_BROKEN);

						/* Cursed */
						o_ptr->ident |= (IDENT_CURSED);

						/* Reverse bonus */
						o_ptr->to_h = 0 - (o_ptr->to_h);
					}

					break;
				}

			}

			break;
		}

		case TV_AMULET:
		{
			/* Analyze */
			switch (o_ptr->sval)
			{
				/* Amulet of wisdom/charisma/infravision */
				case SV_AMULET_WISDOM:
				case SV_AMULET_CHARISMA:
				case SV_AMULET_INFRAVISION:
				{
					/* Stat bonus */
					o_ptr->pval = 1 + m_bonus(5 + (level / 35), level);

					/*cut it off at 6*/
					if (o_ptr->pval > 6) o_ptr->pval = 6;

					/* Cursed */
					if (power < 0)
					{
						/* Broken */
						o_ptr->ident |= (IDENT_BROKEN);

						/* Cursed */
						o_ptr->ident |= (IDENT_CURSED);

						/* Reverse bonuses */
						o_ptr->pval = 0 - (o_ptr->pval);
					}

					break;
				}

				/* Amulet of searching */
				case SV_AMULET_SEARCHING:
				{
					o_ptr->pval = randint(5) + m_bonus(5, level);

					/* Cursed */
					if (power < 0)
					{
						/* Broken */
						o_ptr->ident |= (IDENT_BROKEN);

						/* Cursed */
						o_ptr->ident |= (IDENT_CURSED);

						/* Reverse bonuses */
						o_ptr->pval = 0 - (o_ptr->pval);
					}

					break;
				}

				/* Amulet of ESP -- never cursed */
				case SV_AMULET_ESP:
				{
					o_ptr->pval = randint(5) + m_bonus(5, level);

					break;
				}

				/* Amulet of the Magi -- never cursed */
				case SV_AMULET_THE_MAGI:
				{
					o_ptr->pval = 1 + m_bonus(3, level);
					o_ptr->to_a = randint(5) + m_bonus(5, level);

					/* Boost the rating */
					rating += 10;

					/* Mention the item */
					if (cheat_peek) object_mention(o_ptr);

					break;
				}

				/* Amulet of Devotion -- never cursed */
				case SV_AMULET_DEVOTION:
				{
					o_ptr->pval = 1 + m_bonus(3, level);

					/* Boost the rating */
					rating += 10;

					/* Mention the item */
					if (cheat_peek) object_mention(o_ptr);

					break;
				}

				/* Amulet of Weaponmastery -- never cursed */
				case SV_AMULET_WEAPONMASTERY:
				{
					o_ptr->to_h = 1 + m_bonus(4, level);
					o_ptr->to_d = 1 + m_bonus(4, level);
					o_ptr->pval = 1 + m_bonus(2, level);

					/* Boost the rating */
					rating += 10;

					/* Mention the item */
					if (cheat_peek) object_mention(o_ptr);

					break;
				}

				/* Amulet of Trickery -- never cursed */
				case SV_AMULET_TRICKERY:
				{
					o_ptr->pval = randint(1) + m_bonus(3, level);

					/* Boost the rating */
					rating += 10;

					/* Mention the item */
					if (cheat_peek) object_mention(o_ptr);

					break;
				}

				/* Amulet of Doom -- always cursed */
				case SV_AMULET_DOOM:
				case SV_AMULET_WOE:
				{
					/* Broken */
					o_ptr->ident |= (IDENT_BROKEN);

					/* Cursed */
					o_ptr->ident |= (IDENT_CURSED);

					/* Penalize */
					o_ptr->pval = 0 - (randint(5) + m_bonus(5, level));
					o_ptr->to_a = 0 - (randint(5) + m_bonus(5, level));

					break;
				}
			}

			break;
		}
	}
}


/*
 * Apply magic to an item known to be "boring"
 *
 * Hack -- note the special code for various items
 */
static void a_m_aux_4(object_type *o_ptr, int level, int power, bool good, bool great)
{
	object_kind *k_ptr = &k_info[o_ptr->k_idx];

	/* Unused parameters */
	(void)level;
	(void)power;

	/* Apply magic (good or bad) according to type */
	switch (o_ptr->tval)
	{
		case TV_LIGHT:
		{
			/* Hack -- Torches -- random fuel */
			if (o_ptr->sval == SV_LIGHT_TORCH)
			{
				o_ptr->timeout = DEFAULT_TORCH;
			}

			/* Hack -- Lanterns -- random fuel */
			else if (o_ptr->sval == SV_LIGHT_LANTERN)
			{
				o_ptr->timeout = DEFAULT_LAMP;
			}

			break;
		}

		case TV_WAND:
		{
			/* Hack -- charge wands */
			o_ptr->pval = charge_wand(o_ptr, 100);

			break;
		}

		case TV_STAFF:
		{
			/* Hack -- charge staffs */
			o_ptr->pval = charge_staff(o_ptr, 100);

			break;
		}

		case TV_ROD:
		{
			/* Transfer the pval. */
			o_ptr->pval = k_ptr->pval;
			break;
		}

		case TV_CHEST:
		{
			/* Hack -- chest level is fixed at player level at time of generation */
			o_ptr->pval = object_level;

			/*chest created with good flag get a level boost*/
			if (good) o_ptr->pval += 5;

			/*chest created with great flag also gets a level boost*/
			if (great) o_ptr->pval += 5;

			/*chests now increase level rating*/
			rating += 5;

			/* Don't exceed "chest level" of 110 */
			if (o_ptr->pval > 110) o_ptr->pval = 110;

			/*a minimum pval of 1, or else it will be empty in the town*/
			if (o_ptr->pval < 1) o_ptr->pval = 1;

			/*a guild reward chest shouldn't be trapped*/
			if (object_generation_mode == OB_GEN_MODE_QUEST) o_ptr->pval = (0 - o_ptr->pval);

			/*save the chest theme in xtra1, used in chest death*/
			o_ptr->xtra1 = choose_chest_contents ();

			break;
		}
	}
}

void object_into_artifact(object_type *o_ptr, artifact_type *a_ptr)
{

	/* Extract the other fields */
	o_ptr->pval = a_ptr->pval;
	o_ptr->ac = a_ptr->ac;
	o_ptr->dd = a_ptr->dd;
	o_ptr->ds = a_ptr->ds;
	o_ptr->to_a = a_ptr->to_a;
	o_ptr->to_h = a_ptr->to_h;
	o_ptr->to_d = a_ptr->to_d;
	o_ptr->weight = a_ptr->weight;

	/* Hack - mark the depth of artifact creation for the notes function
	 * probably a bad idea to use this flag.  It is used when making ego-items,
	 * which currently fails when an item is an artifact.  If this was changed
	 * this would be the cause of some major bugs.
	 */
	if (p_ptr->depth)
	{
		o_ptr->xtra1 = p_ptr->depth;
	}

	/*hack - mark chest items with a special level so the notes patch
	 * knows where it is coming from.
	 */
	else if (object_generation_mode == OB_GEN_MODE_CHEST) o_ptr->xtra1 = CHEST_LEVEL;
	else if (object_generation_mode == OB_GEN_MODE_QUEST) o_ptr->xtra1 = QUEST_LEVEL;

	/* Hack -- extract the "broken" flag */
	if (!a_ptr->cost) o_ptr->ident |= (IDENT_BROKEN);

	/* Hack -- extract the "cursed" flag */
	if (a_ptr->a_flags3 & (TR3_LIGHT_CURSE)) o_ptr->ident |= (IDENT_CURSED);
	if (a_ptr->a_flags3 & (TR3_HEAVY_CURSE)) o_ptr->ident |= (IDENT_CURSED);
	if (a_ptr->a_flags3 & (TR3_PERMA_CURSE)) o_ptr->ident |= (IDENT_CURSED);

	/* Hack -- extract the "perfect balance" flag */
	if (a_ptr->a_flags3 & (TR3_PERFECT_BALANCE)) o_ptr->ident |= (IDENT_PERFECT_BALANCE);
}

/*
 * Complete the "creation" of an object by applying "magic" to the item
 *
 * This includes not only rolling for random bonuses, but also putting the
 * finishing touches on ego-items and artifacts, giving charges to wands and
 * staffs, giving fuel to lites, and placing traps on chests.
 *
 * In particular, note that "Instant Artifacts", if "created" by an external
 * routine, must pass through this function to complete the actual creation.
 *
 * The base "chance" of the item being "good" increases with the "level"
 * parameter, which is usually derived from the dungeon level, being equal
 * to the level plus 10, up to a maximum of 75.  If "good" is true, then
 * the object is guaranteed to be "good".  If an object is "good", then
 * the chance that the object will be "great" (ego-item or artifact), also
 * increases with the "level", being equal to half the level, plus 5, up to
 * a maximum of 20.  If "great" is true, then the object is guaranteed to be
 * "great".  At dungeon level 65 and below, 15/100 objects are "great".
 *
 * If the object is not "good", there is a chance it will be "cursed", and
 * if it is "cursed", there is a chance it will be "broken".  These chances
 * are related to the "good" / "great" chances above.
 *
 * Otherwise "normal" rings and amulets will be "good" half the time and
 * "cursed" half the time, unless the ring/amulet is always good or cursed.
 *
 * If "okay" is true, and the object is going to be "great", then there is
 * a chance that an artifact will be created.  This is true even if both the
 * "good" and "great" arguments are false.  Objects which are forced "great"
 * get three extra "attempts" to become an artifact.
 */
void apply_magic(object_type *o_ptr, int lev, bool okay, bool good, bool great, bool interesting)
{
	int i, rolls, test_good, test_great, power;

	/* Maximum "level" for various things */
	if (lev > MAX_DEPTH - 1) lev = MAX_DEPTH - 1;

	/* Base chance of being "good" */
	/* Moriais a base +15 */
	if (game_mode == GAME_NPPMORIA) test_good = lev + 15;
	else test_good = lev + 10;

	/* Maximal chance of being "good" */
	if (game_mode == GAME_NPPMORIA)
	{
		if (test_good > 70) test_good = 70;
	}
	else if (test_good > 75) test_good = 75;

	/* Base chance of being "great", different for Moria */
	if (game_mode == GAME_NPPMORIA) test_great = test_good / 6;
	else test_great = test_good / 2;

	/* Maximal chance of being "great" */
	if (test_great > 20) test_great = 20;

	/* Assume normal */
	power = 0;

	/* Roll for "good", notice that great items don't necessarily need the good flag */
	if ((good) || (great) || (rand_int(100) < test_good))
	{
		/* Assume "good" */
		power = 1;

		/* Roll for "great" */
		if (great || (rand_int(100) < test_great)) power = 2;
	}

	/* Roll for "cursed if not opening a chest" */
	else if ((rand_int(100) < test_good) && (!interesting) &&
		     (object_generation_mode != OB_GEN_MODE_CHEST))
	{
		/* Assume "cursed" */
		power = -1;

		/* Roll for "broken" */
		if (rand_int(100) < test_great) power = -2;
	}

	/* Assume no rolls */
	rolls = 0;

	/* Get one roll if excellent */
	if (power >= 2) rolls = 1;

	/*
	 * Get four rolls if good and great flags are true,
	 * only 2 for quests ince they are so repetitive
	 */
	if ((good) && (great))
	{
		if (object_generation_mode == OB_GEN_MODE_QUEST) rolls = 1;
		else rolls = 4;
	}

	/* Get no rolls if not allowed */
	if (!okay || o_ptr->art_num) rolls = 0;

	/* Roll for artifacts if allowed */
	for (i = 0; i < rolls; i++)
	{
		/* Roll for an artifact */
		if (make_artifact(o_ptr)) break;
	}

	/* Hack -- analyze artifacts */
	if (o_ptr->art_num)
	{
		artifact_type *a_ptr = &a_info[o_ptr->art_num];

		/* Hack -- Mark the artifact as "created" */
		a_ptr->a_cur_num = 1;

		object_into_artifact(o_ptr, a_ptr);

		/* Mega-Hack -- increase the rating */
		rating += 10;

		/* Mega-Hack -- increase the rating again */
		if (a_ptr->cost > 50000L) rating += 10;

		/* Set the good item flag */
		good_item_flag = TRUE;

		/* Cheat -- peek at the item */
		if (cheat_peek) object_mention(o_ptr);

		/* Done */
		return;
	}


	/* Apply magic */
	switch (o_ptr->tval)
	{
		case TV_DIGGING:
		case TV_HAFTED:
		case TV_POLEARM:
		case TV_SWORD:
		case TV_BOW:
		case TV_SHOT:
		case TV_ARROW:
		case TV_BOLT:
		{
			if ((power > 1) || (power < -1))
			{
				int ego_power;

				ego_power = make_ego_item(o_ptr, (bool)(good || great), great);

				if (ego_power) power = ego_power;
			}

			if (power) a_m_aux_1(o_ptr, lev, power);

			break;
		}

		case TV_HARD_ARMOR:
		case TV_SOFT_ARMOR:
		case TV_SHIELD:
		case TV_HELM:
		case TV_CROWN:
		case TV_CLOAK:
		case TV_GLOVES:
		case TV_BOOTS:
		{
			if ((power > 1) || (power < -1))
			{
				int ego_power;

				ego_power = make_ego_item(o_ptr, (bool)(good || great), great);

				if (ego_power) power = ego_power;
			}

			if (power) a_m_aux_2(o_ptr, lev, power);

			break;
		}

		/*Dragon Armor or shield is always an ego-item*/
		case TV_DRAG_ARMOR:
		case TV_DRAG_SHIELD:
		{
			/*Always great*/
			power = 2;

			/*Continue until success*/
			while (!make_ego_item(o_ptr, TRUE, TRUE)) continue;

			/*add the power*/
			a_m_aux_2(o_ptr, lev, power);
		}


		case TV_RING:
		case TV_AMULET:
		{
			if (!power && !interesting && (one_in_(2))) power = -1;
			a_m_aux_3(o_ptr, lev, power);
			break;
		}

		case TV_LIGHT:
		{
			if ((power > 1) || (power < -1))
			{
				make_ego_item(o_ptr, (bool)(good || great), great);
			}

			/* Fuel it */
			a_m_aux_4(o_ptr, lev, power, good, great);
			break;
		}

		case TV_MAGIC_BOOK:
		case TV_PRAYER_BOOK:
		case TV_DRUID_BOOK:
		{
		  	if ((power > 1) || (power < -1))
			{
			  	make_ego_item(o_ptr, (bool)(good || great), great);
			}

			a_m_aux_4(o_ptr, lev, power, good, great);
 			break;
		}

		default:
		{
			a_m_aux_4(o_ptr, lev, power, good, great);
			break;
		}
	}


	/* Hack -- analyze ego-items */
	if (o_ptr->ego_num)
	{
		ego_item_type *e_ptr = &e_info[o_ptr->ego_num];
		u32b f1, f2, f3, fn;

		/* Examine the item */
		object_flags(o_ptr, &f1, &f2, &f3, &fn);

		/* Extra powers */
		if (e_ptr->xtra)
		{
			byte size = 0;
			byte max_flags;
			u32b flag, base = 0;
			u32b flag_cur = 0;
			int x;

			/*Mark what type of extra feature we have here*/
			o_ptr->xtra1 = e_ptr->xtra;

			switch (o_ptr->xtra1)
			{
				case OBJECT_XTRA_STAT_SUSTAIN:
				{
					size = OBJECT_XTRA_SIZE_SUSTAIN;
					base = OBJECT_XTRA_BASE_SUSTAIN;
					flag_cur = f2;
					break;
				}

				case OBJECT_XTRA_TYPE_HIGH_RESIST:
				{
					size = OBJECT_XTRA_SIZE_HIGH_RESIST;
					base = OBJECT_XTRA_BASE_HIGH_RESIST;
					flag_cur = f2;
					break;
				}

				case OBJECT_XTRA_TYPE_POWER:
				{
					size = OBJECT_XTRA_SIZE_POWER;
					base = OBJECT_XTRA_BASE_POWER;
					flag_cur = f3;
					break;
				}
				case OBJECT_XTRA_TYPE_IMMUNITY:
				{
					size = OBJECT_XTRA_SIZE_IMMUNITY;
					base = OBJECT_XTRA_BASE_IMMUNITY;
					flag_cur = f2;
					break;
				}
				case OBJECT_XTRA_TYPE_STAT_ADD:
				{
					size = OBJECT_XTRA_SIZE_STAT_ADD;
					base = OBJECT_XTRA_BASE_STAT_ADD;
					flag_cur = f1;

					/* Calculate Stat bonus */
					o_ptr->pval = 1 + m_bonus(5 + (lev / 35), lev);

					/*cut it off at 6*/
					if (o_ptr->pval > 6) o_ptr->pval = 6;
					break;
				}
				case OBJECT_XTRA_TYPE_SLAY:
				{
					size = OBJECT_XTRA_SIZE_SLAY;
					base = OBJECT_XTRA_BASE_SLAY;
					flag_cur = f1;
					break;
				}
				case OBJECT_XTRA_TYPE_KILL:
				{
					size = OBJECT_XTRA_SIZE_KILL;
					base = OBJECT_XTRA_BASE_KILL;
					flag_cur = f1;
					break;
				}
				case OBJECT_XTRA_TYPE_BRAND:
				{
					size = OBJECT_XTRA_SIZE_BRAND;
					base = OBJECT_XTRA_BASE_BRAND;
					flag_cur = f1;
					break;
				}
				case OBJECT_XTRA_TYPE_LOW_RESIST:
				{
					size = OBJECT_XTRA_SIZE_LOW_RESIST;
					base = OBJECT_XTRA_BASE_LOW_RESIST;
					flag_cur = f2;
					break;
				}
				case OBJECT_XTRA_TYPE_NATIVE:
				{
					size = OBJECT_XTRA_SIZE_NATIVE;
					base = OBJECT_XTRA_BASE_NATIVE;
					flag_cur = fn;
					break;
				}
			}

			/*start with a clean slate*/
			o_ptr->xtra2 = 0;

			/* Mark when there are no more flags to give */
			max_flags = size;

			/*Check to see if any object already has some of these flags*/
			for (x = 0; x < size; x++)
			{
				/*Go to the flag*/
				u32b current_bit = base << x;

				/* Do we have this flag already?*/
				if (flag_cur & current_bit)
				{
					/*Mark it in xtra2*/
					flag = 0x00000001L << x;

					/* Assign the flag */
					o_ptr->xtra2 |= flag;

					/* Note how many we have left */
					max_flags--;
				}


			}

			while (max_flags)
			{
				/* Make a random flag */
				flag = 0x00000001L << rand_int(size);

				/* Duplicated flag? */
				if (o_ptr->xtra2 & flag)	continue;

				/* Assign the flag */
				o_ptr->xtra2 |= flag;

				/* Note how many we have left */
				max_flags--;

			  	/* Another flag sometimes? */
			  	if (!one_in_(EXTRA_FLAG_CHANCE)) break;

			}
		}

		/* Ego-item throwing weapons may sometimes be perfectly
		 * balanced.
		 */
		if ((f3 & (TR3_THROWING)) && (randint(3) == 1))
		{
			(o_ptr->ident |= IDENT_PERFECT_BALANCE);
		}

		if (f3 & (TR3_PERFECT_BALANCE))
		{
			(o_ptr->ident |= IDENT_PERFECT_BALANCE);
		}

		/* Hack -- acquire "broken" flag */
		if (!e_ptr->cost) o_ptr->ident |= (IDENT_BROKEN);

		/* Hack -- acquire "cursed" flag */
		if (e_ptr->flags3 & (TR3_LIGHT_CURSE)) o_ptr->ident |= (IDENT_CURSED);
		if (e_ptr->flags3 & (TR3_HEAVY_CURSE)) o_ptr->ident |= (IDENT_CURSED);
		if (e_ptr->flags3 & (TR3_PERMA_CURSE)) o_ptr->ident |= (IDENT_CURSED);

		/* Hack -- apply extra penalties if needed */
		if (cursed_p(o_ptr) || broken_p(o_ptr))
		{
			/* Hack -- obtain bonuses */
			if (e_ptr->max_to_h > 0) o_ptr->to_h -= randint(e_ptr->max_to_h);
			if (e_ptr->max_to_d > 0) o_ptr->to_d -= randint(e_ptr->max_to_d);
			if (e_ptr->max_to_a > 0) o_ptr->to_a -= randint(e_ptr->max_to_a);

			/* Hack -- obtain pval, unless one has already been assigned */
			if ((e_ptr->max_pval > 0) && (o_ptr->pval == 0))
				  o_ptr->pval -= randint(e_ptr->max_pval);
		}

		/* Hack -- apply extra bonuses if needed */
		else
		{
			/* Hack -- obtain bonuses */
			if (e_ptr->max_to_h > 0) o_ptr->to_h += randint(e_ptr->max_to_h);
			if (e_ptr->max_to_d > 0) o_ptr->to_d += randint(e_ptr->max_to_d);
			if (e_ptr->max_to_a > 0) o_ptr->to_a += randint(e_ptr->max_to_a);

			/* Hack -- obtain pval */
			if (e_ptr->max_pval > 0)
			{
				/*Handle stat pvals differently*/
				if (e_ptr->flags1 & TR1_ALL_STATS)
				{
					byte bonus = m_bonus(e_ptr->max_pval, lev);

					/*min of 1*/
					if (bonus < 1) bonus = 1;

					o_ptr->pval += bonus;

					/*hard limit*/
					if(o_ptr->pval > 6) o_ptr->pval = 6;
				}
				else o_ptr->pval += randint(e_ptr->max_pval);
			}
		}

		/* Hack -- apply rating bonus */
		rating += e_ptr->rating;

		/* Cheat -- describe the item */
		if (cheat_peek) object_mention(o_ptr);

		/* Done */
		return;
	}


	/* Examine real objects */
	if (o_ptr->k_idx)
	{
		object_kind *k_ptr = &k_info[o_ptr->k_idx];

		/* Hack -- acquire "broken" flag */
		if (!k_ptr->cost) o_ptr->ident |= (IDENT_BROKEN);

		/* Hack -- acquire "cursed" flag */
		if (k_ptr->k_flags3 & (TR3_LIGHT_CURSE)) o_ptr->ident |= (IDENT_CURSED);
		if (k_ptr->k_flags3 & (TR3_HEAVY_CURSE)) o_ptr->ident |= (IDENT_CURSED);
		if (k_ptr->k_flags3 & (TR3_PERMA_CURSE)) o_ptr->ident |= (IDENT_CURSED);
	}
}

/*
 * Hack -- determine if a template is suitable for a general store.
 *
 * Note that this test only applies to the object *kind*, so it is
 * possible to cause the object to be cursed.
 */
static bool kind_is_gen_store_moria(int k_idx)
{
	object_kind *k_ptr = &k_info[k_idx];

	/* No "worthless" items */
	if (k_ptr->cost < 0) return (FALSE);

	/* Analyze the item type */
	switch (k_ptr->tval)
	{
		/* Certain kinds of food is sold there*/
		case TV_FOOD:
		{
			if (k_ptr->sval == SV_FOOD_RATION) return (TRUE);
			if (k_ptr->sval == SV_FOOD_BISCUIT) return (TRUE);
			if (k_ptr->sval == SV_FOOD_BEEF_JERKY) return (TRUE);
			if (k_ptr->sval == SV_FOOD_FINE_ALE) return (TRUE);
			if (k_ptr->sval == SV_FOOD_FINE_WINE) return (TRUE);
			return (FALSE);
		}

		/* Non artifact Lite Sources are sold there*/
		case TV_LIGHT:
		{
			if (k_ptr->sval == SV_LIGHT_TORCH) return (TRUE);
			if (k_ptr->sval == SV_LIGHT_LANTERN) return (TRUE);
			return (FALSE);
		}

		/* Flasks and Spikes are sold there*/
		case TV_FLASK:
		case TV_SPIKE:
		{
			return (TRUE);
		}

		/* Shovels and Picks are sold there*/
		case TV_DIGGING:
		{
			if (k_ptr->sval == SV_SHOVEL) return (TRUE);
			if (k_ptr->sval == SV_PICK) return (TRUE);
			return (FALSE);
		}

		case TV_SOFT_ARMOR:
		{
			if (k_ptr->sval == SV_ROBE) return (TRUE);
			return (FALSE);
		}

		/*
		 *  Normal Cloaks are sold there
		 */
		case TV_CLOAK:
		{
			if (k_ptr->sval == SV_CLOAK) return (TRUE);
			return (FALSE);
		}
	}

	/* Assume not good */
	return (FALSE);
}



/*
 * Hack -- determine if a template is suitable for a general store.
 *
 * Note that this test only applies to the object *kind*, so it is
 * possible to cause the object to be cursed.
 */
static bool kind_is_gen_store(int k_idx)
{
	object_kind *k_ptr = &k_info[k_idx];

	/* No "worthless" items */
	if (k_ptr->cost < 0) return (FALSE);

	/* Analyze the item type */
	switch (k_ptr->tval)
	{
		/* Certain kinds of food is sold there*/
		case TV_FOOD:
		{
			if (allow_altered_inventory) return (TRUE);
			if (k_ptr->sval == SV_FOOD_RATION) return (TRUE);
			return (FALSE);
		}

		/* Non artifact Lite Sources are sold there*/
		case TV_LIGHT:
		{
			if (k_ptr->sval == SV_LIGHT_TORCH) return (TRUE);
			if (k_ptr->sval == SV_LIGHT_LANTERN) return (TRUE);
			return (FALSE);
		}

		/* Flasks and Spikes are sold there*/
		case TV_FLASK:
		case TV_SPIKE:
		{
			return (TRUE);
		}

		/*Normal ammo is sold there*/
		case TV_SHOT:
		case TV_ARROW:
		case TV_BOLT:
		{
			if (allow_altered_inventory) return (TRUE);
			if (k_ptr->sval == SV_AMMO_NORMAL) return (TRUE);
			if (k_ptr->sval == SV_AMMO_LIGHT) return (TRUE);
			return (FALSE);
		}

		/* Shovels and Picks are sold there*/
		case TV_DIGGING:
		{
			if (allow_altered_inventory) return (TRUE);
			if (k_ptr->sval == SV_SHOVEL) return (TRUE);
			if (k_ptr->sval == SV_PICK) return (TRUE);
			return (FALSE);
		}

		/*
		 *  Normal Cloaks are sold there
		 */
		case TV_CLOAK:
		{
			if (allow_altered_inventory) return (TRUE);
			if (k_ptr->sval == SV_CLOAK) return (TRUE);
			return (FALSE);
		}
	}

	/* Assume not good */
	return (FALSE);
}



/*
 * Hack -- determine if a template is suitable for the armoury.
 *
 * Note that this test only applies to the object *kind*, so it is
 * possible to cause the object to be cursed.
 */
static bool kind_is_armoury(int k_idx)
{
	object_kind *k_ptr = &k_info[k_idx];

	/* No "worthless" items */
	if (k_ptr->cost < 0) return (FALSE);

	/* Analyze the item type */
	switch (k_ptr->tval)
	{
		/* Armor -- Good unless damaged */
		case TV_HARD_ARMOR:
		{
			if (allow_altered_inventory) return (TRUE);
			if (k_ptr->sval == SV_METAL_SCALE_MAIL) return (TRUE);
			if (k_ptr->sval == SV_CHAIN_MAIL) return (TRUE);
			if (k_ptr->sval == SV_AUGMENTED_CHAIN_MAIL) return (TRUE);
			if (k_ptr->sval == SV_DOUBLE_CHAIN_MAIL) return (TRUE);
			if (k_ptr->sval == SV_METAL_BRIGANDINE_ARMOUR) return (TRUE);
			return(FALSE);

		}
		case TV_SOFT_ARMOR:
		{
			if (allow_altered_inventory) return (TRUE);
			if (k_ptr->sval == SV_ROBE) return (TRUE);
			if (k_ptr->sval == SV_SOFT_LEATHER_ARMOR) return (TRUE);
			if (k_ptr->sval == SV_HARD_LEATHER_ARMOR) return (TRUE);
			if (k_ptr->sval == SV_HARD_STUDDED_LEATHER) return (TRUE);
			if (k_ptr->sval == SV_LEATHER_SCALE_MAIL) return (TRUE);
			return(FALSE);
		}

		case TV_SHIELD:
		{
			if (allow_altered_inventory) return (TRUE);
			if (k_ptr->sval == SV_SMALL_LEATHER_SHIELD) return (TRUE);
			if (k_ptr->sval == SV_SMALL_METAL_SHIELD) return (TRUE);
			return(FALSE);
		}
		case TV_BOOTS:
		{
			if (allow_altered_inventory) return (TRUE);
			if (k_ptr->sval == SV_PAIR_OF_SOFT_LEATHER_BOOTS) return (TRUE);
			if (k_ptr->sval == SV_PAIR_OF_HARD_LEATHER_BOOTS) return (TRUE);
			return(FALSE);
		}
		case TV_GLOVES:
		{
			if (allow_altered_inventory) return (TRUE);
			if (k_ptr->sval == SV_SET_OF_LEATHER_GLOVES) return (TRUE);
			if (k_ptr->sval == SV_SET_OF_GAUNTLETS) return (TRUE);
			return(FALSE);
		}
		case TV_HELM:
		{
			if (allow_altered_inventory) return (TRUE);
			if (k_ptr->sval == SV_HARD_LEATHER_CAP) return (TRUE);
			if (k_ptr->sval == SV_IRON_HELM) return (TRUE);
			return(FALSE);
		}
	}

	/* Assume not good */
	return (FALSE);
}

/*
 * Hack -- determine if a template is suitable for the armoury.
 *
 * Note that this test only applies to the object *kind*, so it is
 * possible to cause the object to be cursed.
 */
static bool kind_is_armoury_moria(int k_idx)
{
	object_kind *k_ptr = &k_info[k_idx];

	/* No "worthless" items */
	if (k_ptr->cost < 0) return (FALSE);

	/* Analyze the item type */
	switch (k_ptr->tval)
	{
		/* Armor -- Good unless damaged */
		case TV_HARD_ARMOR:
		{
			if (k_ptr->sval == SV_METAL_SCALE_MAIL) return (TRUE);
			if (k_ptr->sval == SV_CHAIN_MAIL) return (TRUE);
			if (k_ptr->sval == SV_DOUBLE_CHAIN_MAIL) return (TRUE);
			if (k_ptr->sval == SV_BAR_CHAIN_MAIL) return (TRUE);
			return(FALSE);

		}
		case TV_SOFT_ARMOR:
		{
			if (k_ptr->sval == SV_SOFT_LEATHER_ARMOR) return (TRUE);
			if (k_ptr->sval == SV_SOFT_STUDDED_LEATHER) return (TRUE);
			if (k_ptr->sval == SV_HARD_LEATHER_ARMOR) return (TRUE);
			if (k_ptr->sval == SV_HARD_STUDDED_LEATHER) return (TRUE);
			if (k_ptr->sval == SV_LEATHER_RING_MAIL_HARD) return (TRUE);
			if (k_ptr->sval == SV_LEATHER_SCALE_MAIL) return (TRUE);
			return(FALSE);
		}

		case TV_SHIELD:
		{
			if (k_ptr->sval == SV_SMALL_LEATHER_SHIELD) return (TRUE);
			if (k_ptr->sval == SV_MEDIUM_LEATHER_SHIELD) return (TRUE);
			if (k_ptr->sval == SV_SMALL_METAL_SHIELD) return (TRUE);
			return(FALSE);
		}
		case TV_BOOTS:
		{
			if (k_ptr->sval == SV_PAIR_OF_SOFT_LEATHER_SHOES) return (TRUE);
			if (k_ptr->sval == SV_PAIR_OF_SOFT_LEATHER_BOOTS) return (TRUE);
			return(FALSE);
		}
		case TV_GLOVES:
		{
			if (k_ptr->sval == SV_SET_OF_LEATHER_GLOVES) return (TRUE);
			if (k_ptr->sval == SV_SET_OF_GAUNTLETS) return (TRUE);
			return(FALSE);
		}
		case TV_HELM:
		{
			if (k_ptr->sval == SV_HARD_LEATHER_CAP) return (TRUE);
			if (k_ptr->sval == SV_SOFT_LEATHER_CAP) return (TRUE);
			if (k_ptr->sval == SV_METAL_CAP) return (TRUE);
			return(FALSE);
		}
	}

	/* Assume not good */
	return (FALSE);
}

/*
 * Hack -- determine if a template is suitable for the weaponsmith.
 *
 * Note that this test only applies to the object *kind*, so it is
 * possible to cause the object to be cursed.
 */
static bool kind_is_weaponsmith_moria(int k_idx)
{
	object_kind *k_ptr = &k_info[k_idx];

	/* No "worthless" items */
	if (k_ptr->cost < 0) return (FALSE);

	/* Analyze the item type */
	switch (k_ptr->tval)
	{
		/* Weapons -- suitable  unless damaged */
		case TV_SWORD:
		{
			if (k_ptr->sval == SV_DAGGER_STILLETO) return (TRUE);
			if (k_ptr->sval == SV_DAGGER_MISERICORDE) return (TRUE);
			if (k_ptr->sval == SV_BASTARD_SWORD) return (TRUE);
			if (k_ptr->sval == SV_BROAD_SWORD) return (TRUE);
			if (k_ptr->sval == SV_LONG_SWORD) return (TRUE);
			if (k_ptr->sval == SV_SMALL_SWORD) return (TRUE);
			return (FALSE);
		}
		case TV_HAFTED:
		{
			if (k_ptr->sval == SV_MORNING_STAR) return (TRUE);
			if (k_ptr->sval == SV_MACE) return (TRUE);
			if (k_ptr->sval == SV_WAR_HAMMER) return (TRUE);
			return (FALSE);
		}
		case TV_POLEARM:
		{

			if (k_ptr->sval == SV_HALBERD) return (TRUE);
			if (k_ptr->sval == SV_PIKE) return (TRUE);
			if (k_ptr->sval == SV_SPEAR) return (TRUE);
			if (k_ptr->sval == SV_BROAD_AXE) return (TRUE);
			return (FALSE);
		}
		case TV_BOW:
		{
			if (k_ptr->sval == SV_SLING) return (TRUE);
			if (k_ptr->sval == SV_SHORT_BOW) return (TRUE);
			if (k_ptr->sval == SV_LONG_BOW) return (TRUE);
			if (k_ptr->sval == SV_LIGHT_XBOW) return (TRUE);
			return (FALSE);
		}
		/*Normal ammo is sold there*/
		case TV_SHOT:
		case TV_ARROW:
		case TV_BOLT:
		{
			if (k_ptr->sval == SV_AMMO_NORMAL) return (TRUE);
			if (k_ptr->sval == SV_AMMO_LIGHT) return (TRUE);
			return (FALSE);
		}

	}

	/* Assume not suitable */
	return (FALSE);
}


/*
 * Hack -- determine if a template is suitable for the weaponsmith.
 *
 * Note that this test only applies to the object *kind*, so it is
 * possible to cause the object to be cursed.
 */
static bool kind_is_weaponsmith(int k_idx)
{
	object_kind *k_ptr = &k_info[k_idx];

	/* No "worthless" items */
	if (k_ptr->cost < 0) return (FALSE);

	/* Analyze the item type */
	switch (k_ptr->tval)
	{
		/* Weapons -- suitable  unless damaged */
		case TV_SWORD:
		{
			if (allow_altered_inventory) return (TRUE);
			if (k_ptr->sval == SV_DAGGER) return (TRUE);
			if (k_ptr->sval == SV_MAIN_GAUCHE) return (TRUE);
			if (k_ptr->sval == SV_RAPIER) return (TRUE);
			if (k_ptr->sval == SV_SMALL_SWORD) return (TRUE);
			if (k_ptr->sval == SV_SHORT_SWORD) return (TRUE);
			if (k_ptr->sval == SV_SABRE) return (TRUE);
			if (k_ptr->sval == SV_CUTLASS) return (TRUE);
			if (k_ptr->sval == SV_BROAD_SWORD) return (TRUE);
			if (k_ptr->sval == SV_LONG_SWORD) return (TRUE);
			if (k_ptr->sval == SV_SCIMITAR) return (TRUE);
			if (k_ptr->sval == SV_KATANA) return (TRUE);
			if (k_ptr->sval == SV_BASTARD_SWORD) return (TRUE);
			return (FALSE);
		}
		case TV_HAFTED:
		{
			if (allow_altered_inventory) return (TRUE);
			if (k_ptr->sval == SV_WHIP) return (TRUE);
			return (FALSE);
		}
		case TV_POLEARM:
		{
			if (allow_altered_inventory) return (TRUE);
			if (k_ptr->sval == SV_SPEAR) return (TRUE);
			if (k_ptr->sval == SV_AWL_PIKE) return (TRUE);
			if (k_ptr->sval == SV_TRIDENT) return (TRUE);
			if (k_ptr->sval == SV_PIKE) return (TRUE);
			if (k_ptr->sval == SV_BEAKED_AXE) return (TRUE);
			if (k_ptr->sval == SV_BROAD_AXE) return (TRUE);
			if (k_ptr->sval == SV_BATTLE_AXE) return (TRUE);
			return (FALSE);
		}
		case TV_BOW:
		{
			if (allow_altered_inventory) return (TRUE);
			if (k_ptr->sval == SV_SLING) return (TRUE);
			if (k_ptr->sval == SV_SHORT_BOW) return (TRUE);
			if (k_ptr->sval == SV_LONG_BOW) return (TRUE);
			if (k_ptr->sval == SV_LIGHT_XBOW) return (TRUE);
			return (FALSE);
		}
		/*Normal ammo is sold there*/
		case TV_SHOT:
		case TV_ARROW:
		case TV_BOLT:
		{
			if (allow_altered_inventory) return (TRUE);
			if (k_ptr->sval == SV_AMMO_NORMAL) return (TRUE);
			if (k_ptr->sval == SV_AMMO_LIGHT) return (TRUE);
			return (FALSE);
		}

	}

	/* Assume not suitable */
	return (FALSE);
}

/*
 * Hack -- determine if a template is suitable for the temple.
 *
 * Note that this test only applies to the object *kind*, so it is
 * possible to cause the object to be cursed.
 */
static bool kind_is_temple(int k_idx)
{
	object_kind *k_ptr = &k_info[k_idx];

	/* No "worthless" items */
	if (k_ptr->cost < 0) return (FALSE);

	/* Analyze the item type */
	switch (k_ptr->tval)
	{
		/* Hafted weapons only in the temple*/
		case TV_HAFTED:
		{
			if (allow_altered_inventory) return (TRUE);
			if (k_ptr->sval == SV_WHIP) return (TRUE);
			if (k_ptr->sval == SV_QUARTERSTAFF) return (TRUE);
			if (k_ptr->sval == SV_MACE) return (TRUE);
			if (k_ptr->sval == SV_BALL_AND_CHAIN) return (TRUE);
			if (k_ptr->sval == SV_WAR_HAMMER) return (TRUE);
			if (k_ptr->sval == SV_LUCERN_HAMMER) return (TRUE);
			if (k_ptr->sval == SV_MORNING_STAR) return (TRUE);
			if (k_ptr->sval == SV_FLAIL) return (TRUE);
			if (k_ptr->sval == SV_LEAD_FILLED_MACE) return (TRUE);
			return (FALSE);
		}
		/*scrolls suitable for the temple*/
		case TV_SCROLL:
		{
			if (allow_altered_inventory) return (TRUE);
			if (k_ptr->sval == SV_SCROLL_REMOVE_CURSE) return (TRUE);
			if (k_ptr->sval == SV_SCROLL_IDENTIFY) return (TRUE);
			if (k_ptr->sval == SV_SCROLL_BLESSING) return (TRUE);
			if (k_ptr->sval == SV_SCROLL_HOLY_CHANT) return (TRUE);
			return (FALSE);
		}
		case TV_POTION:
		{
			if (allow_altered_inventory) return (TRUE);
			if (k_ptr->sval == SV_POTION_BOLDNESS) return (TRUE);
			if (k_ptr->sval == SV_POTION_HEROISM) return (TRUE);
			if (k_ptr->sval == SV_POTION_CURE_LIGHT) return (TRUE);
			if (k_ptr->sval == SV_POTION_CURE_SERIOUS) return (TRUE);
			if (k_ptr->sval == SV_POTION_CURE_CRITICAL) return (TRUE);
			if (k_ptr->sval == SV_POTION_RESTORE_EXP) return (TRUE);
			return (FALSE);
		}

	}

	/* Assume not suitable */
	return (FALSE);
}

/*
 * Hack -- determine if a template is suitable for the temple.
 *
 * Note that this test only applies to the object *kind*, so it is
 * possible to cause the object to be cursed.
 */
static bool kind_is_temple_moria(int k_idx)
{
	object_kind *k_ptr = &k_info[k_idx];

	/* No "worthless" items */
	if (k_ptr->cost < 0) return (FALSE);

	/* Analyze the item type */
	switch (k_ptr->tval)
	{
		/* Hafted weapons only in the temple*/
		case TV_HAFTED:
		{
			if (k_ptr->sval == SV_MORNING_STAR) return (TRUE);
			if (k_ptr->sval == SV_MACE) return (TRUE);
			if (k_ptr->sval == SV_WAR_HAMMER) return (TRUE);
			return (FALSE);
		}
		/*scrolls suitable for the temple*/
		case TV_SCROLL:
		{

			if (k_ptr->sval == SV_SCROLL_REMOVE_CURSE) return (TRUE);
			if (k_ptr->sval == SV_SCROLL_WORD_OF_RECALL) return (TRUE);
			if (k_ptr->sval == SV_SCROLL_BLESSING) return (TRUE);
			return (FALSE);
		}
		case TV_POTION:
		{
			if (k_ptr->sval == SV_POTION_RES_WIS) return (TRUE);
			if (k_ptr->sval == SV_POTION_CURE_LIGHT) return (TRUE);
			if (k_ptr->sval == SV_POTION_CURE_SERIOUS) return (TRUE);
			if (k_ptr->sval == SV_POTION_CURE_CRITICAL) return (TRUE);
			if (k_ptr->sval == SV_POTION_RESTORE_EXP) return (TRUE);
			if (k_ptr->sval == SV_POTION_CURE_POISON) return (TRUE);
			if (k_ptr->sval == SV_POTION_HEROISM) return (TRUE);
			if (k_ptr->sval == SV_POTION_BOLDNESS) return (TRUE);
			return (FALSE);
		}


		case TV_PRAYER_BOOK:
		{
			return (TRUE);
		}
	}

	/* Assume not suitable */
	return (FALSE);
}

/*
 * Hack -- determine if a template is suitable for the alchemy shop.
 *
 * Note that this test only applies to the object *kind*, so it is
 * possible to cause the object to be cursed.
 */
static bool kind_is_alchemy_moria(int k_idx)
{
	object_kind *k_ptr = &k_info[k_idx];

	/* No "worthless" items */
	if (k_ptr->cost < 0) return (FALSE);

	/* Analyze the item type */
	switch (k_ptr->tval)
	{

		/*scrolls suitable for the alchemy shop*/
		case TV_SCROLL:
		{
			if (k_ptr->sval == SV_SCROLL_ENCHANT_WEAPON_TO_HIT) return (TRUE);
			if (k_ptr->sval == SV_SCROLL_ENCHANT_WEAPON_TO_DAM) return (TRUE);
			if (k_ptr->sval == SV_SCROLL_RECHARGING) return (TRUE);
			if (k_ptr->sval == SV_SCROLL_ENCHANT_ARMOR) return (TRUE);
			if (k_ptr->sval == SV_SCROLL_IDENTIFY) return (TRUE);
			if (k_ptr->sval == SV_SCROLL_LIGHT) return (TRUE);
			if (k_ptr->sval == SV_SCROLL_PHASE_DOOR) return (TRUE);
			if (k_ptr->sval == SV_SCROLL_MAPPING) return (TRUE);
			if (k_ptr->sval == SV_SCROLL_DETECT_GOLD) return (TRUE);
			if (k_ptr->sval == SV_SCROLL_DETECT_ITEM) return (TRUE);
			if (k_ptr->sval == SV_SCROLL_WORD_OF_RECALL) return (TRUE);
			return (FALSE);
		}
		case TV_POTION:
		{
			if (k_ptr->sval == SV_POTION_RES_STR) return (TRUE);
			if (k_ptr->sval == SV_POTION_RES_INT) return (TRUE);
			if (k_ptr->sval == SV_POTION_RES_WIS) return (TRUE);
			if (k_ptr->sval == SV_POTION_RES_DEX) return (TRUE);
			if (k_ptr->sval == SV_POTION_RES_CON) return (TRUE);
			if (k_ptr->sval == SV_POTION_RES_CHR) return (TRUE);
			if (k_ptr->sval == SV_POTION_SLOW_POISON) return (TRUE);
			return (FALSE);
		}

	}

	/* Assume not suitable */
	return (FALSE);
}


/*
 * Hack -- determine if a template is suitable for the alchemy shop.
 *
 * Note that this test only applies to the object *kind*, so it is
 * possible to cause the object to be cursed.
 */
static bool kind_is_alchemy(int k_idx)
{
	object_kind *k_ptr = &k_info[k_idx];

	/* No "worthless" items */
	if (k_ptr->cost < 0) return (FALSE);

	/* Analyze the item type */
	switch (k_ptr->tval)
	{

		/*scrolls suitable for the alchemy shop*/
		case TV_SCROLL:
		{
			if (allow_altered_inventory) return (TRUE);
			if (k_ptr->sval == SV_SCROLL_ENCHANT_WEAPON_TO_HIT) return (TRUE);
			if (k_ptr->sval == SV_SCROLL_ENCHANT_WEAPON_TO_DAM) return (TRUE);
			if (k_ptr->sval == SV_SCROLL_ENCHANT_ARMOR) return (TRUE);
			if (k_ptr->sval == SV_SCROLL_IDENTIFY) return (TRUE);
			if (k_ptr->sval == SV_SCROLL_LIGHT) return (TRUE);
			if (k_ptr->sval == SV_SCROLL_PHASE_DOOR) return (TRUE);
			if (k_ptr->sval == SV_SCROLL_MONSTER_CONFUSION) return (TRUE);
			if (k_ptr->sval == SV_SCROLL_MAPPING) return (TRUE);
			if (k_ptr->sval == SV_SCROLL_DETECT_TRAP) return (TRUE);
			if (k_ptr->sval == SV_SCROLL_DETECT_ITEM) return (TRUE);
			if (k_ptr->sval == SV_SCROLL_DETECT_DOOR) return (TRUE);
			if (k_ptr->sval == SV_SCROLL_DETECT_INVIS) return (TRUE);
			if (k_ptr->sval == SV_SCROLL_RECHARGING) return (TRUE);
			if (k_ptr->sval == SV_SCROLL_SATISFY_HUNGER) return (TRUE);
			if (k_ptr->sval == SV_SCROLL_WORD_OF_RECALL) return (TRUE);
			return (FALSE);
		}
		case TV_POTION:
		{
			if (allow_altered_inventory) return (TRUE);
			if (k_ptr->sval == SV_POTION_RESIST_HEAT) return (TRUE);
			if (k_ptr->sval == SV_POTION_RESIST_COLD) return (TRUE);
			if (k_ptr->sval == SV_POTION_RESIST_ELECTRICITY) return (TRUE);
			if (k_ptr->sval == SV_POTION_RESIST_ACID) return (TRUE);
			if (k_ptr->sval == SV_POTION_RES_STR) return (TRUE);
			if (k_ptr->sval == SV_POTION_RES_INT) return (TRUE);
			if (k_ptr->sval == SV_POTION_RES_WIS) return (TRUE);
			if (k_ptr->sval == SV_POTION_RES_DEX) return (TRUE);
			if (k_ptr->sval == SV_POTION_RES_CON) return (TRUE);
			if (k_ptr->sval == SV_POTION_RES_CHR) return (TRUE);
		}

	}

	/* Assume not suitable */
	return (FALSE);
}

/*
 * Hack -- determine if a template is suitable for the magic_shop.
 *
 * Note that this test only applies to the object *kind*, so it is
 * possible to cause the object to be cursed.
 */
static bool kind_is_magic_shop_moria(int k_idx)
{
	object_kind *k_ptr = &k_info[k_idx];

	/* No "worthless" items */
	if (k_ptr->cost < 0) return (FALSE);

	/* Analyze the item type */
	switch (k_ptr->tval)
	{
		/*Rings suitable for the magic_shop*/
		case TV_RING:
		{
			if (k_ptr->sval == SV_RING_RESIST_FIRE) return (TRUE);
			if (k_ptr->sval == SV_RING_RESIST_COLD) return (TRUE);
			if (k_ptr->sval == SV_RING_FEATHER_FALL) return (TRUE);
			if (k_ptr->sval == SV_RING_PROTECTION) return (TRUE);
			return (FALSE);
		}
		/*Amulets suitable for the magic_shop*/
		case TV_AMULET:
		{
			if (k_ptr->sval == SV_AMULET_CHARISMA) return (TRUE);
			if (k_ptr->sval == SV_AMULET_SLOW_DIGEST) return (TRUE);
			if (k_ptr->sval == SV_AMULET_RESIST_ACID) return (TRUE);
			return (FALSE);
		}
		/*Amulets suitable for the magic_shop*/
		case TV_WAND:
		{
			if (k_ptr->sval == SV_WAND_LIGHT) return (TRUE);
			if (k_ptr->sval == SV_WAND_ELEC_BALL) return (TRUE);
			if (k_ptr->sval == SV_WAND_STINKING_CLOUD) return (TRUE);
			if (k_ptr->sval == SV_WAND_WONDER) return (TRUE);
			if (k_ptr->sval == SV_WAND_MAGIC_MISSILE) return (TRUE);
			if (k_ptr->sval == SV_WAND_ELEC_BOLT) return (TRUE);
			if (k_ptr->sval == SV_WAND_DISARMING) return (TRUE);
			return (FALSE);
		}
		/*Staves suitable for the magic_shop*/
		case TV_STAFF:
		{
			if (k_ptr->sval == SV_STAFF_LIGHT) return (TRUE);

			if (k_ptr->sval == SV_STAFF_DETECT_TRAP) return (TRUE);
			if (k_ptr->sval == SV_STAFF_DETECT_DOOR) return (TRUE);
			if (k_ptr->sval == SV_STAFF_DETECT_INVIS) return (TRUE);
			return (FALSE);
		}
		case TV_MAGIC_BOOK:
		{
			return (TRUE);
		}
	}

	/* Assume not suitable */
	return (FALSE);
}



/*
 * Hack -- determine if a template is suitable for the magic_shop.
 *
 * Note that this test only applies to the object *kind*, so it is
 * possible to cause the object to be cursed.
 */
static bool kind_is_magic_shop(int k_idx)
{
	object_kind *k_ptr = &k_info[k_idx];

	/* No "worthless" items */
	if (k_ptr->cost < 0) return (FALSE);

	/* Analyze the item type */
	switch (k_ptr->tval)
	{
		/*Rings suitable for the magic_shop*/
		case TV_RING:
		{
			if (allow_altered_inventory) return (TRUE);
			if (k_ptr->sval == SV_RING_SEARCHING) return (TRUE);
			if (k_ptr->sval == SV_RING_FEATHER_FALL) return (TRUE);
			if (k_ptr->sval == SV_RING_PROTECTION) return (TRUE);
			return (FALSE);
		}
		/*Amulets suitable for the magic_shop*/
		case TV_AMULET:
		{
			if (allow_altered_inventory) return (TRUE);
			if (k_ptr->sval == SV_AMULET_CHARISMA) return (TRUE);
			if (k_ptr->sval == SV_AMULET_SLOW_DIGEST) return (TRUE);
			if (k_ptr->sval == SV_AMULET_RESIST_ACID) return (TRUE);
			return (FALSE);
		}
		/*Amulets suitable for the magic_shop*/
		case TV_WAND:
		{
			if (allow_altered_inventory) return (TRUE);
			if (k_ptr->sval == SV_WAND_SLOW_MONSTER) return (TRUE);
			if (k_ptr->sval == SV_WAND_CONFUSE_MONSTER) return (TRUE);
			if (k_ptr->sval == SV_WAND_SLEEP_MONSTER) return (TRUE);
			if (k_ptr->sval == SV_WAND_MAGIC_MISSILE) return (TRUE);
			if (k_ptr->sval == SV_WAND_STINKING_CLOUD) return (TRUE);
			if (k_ptr->sval == SV_WAND_WONDER) return (TRUE);
			return (FALSE);
		}
		/*Staves suitable for the magic_shop*/
		case TV_STAFF:
		{
			if (allow_altered_inventory) return (TRUE);
			if (k_ptr->sval == SV_STAFF_LIGHT) return (TRUE);
			if (k_ptr->sval == SV_STAFF_MAPPING) return (TRUE);
			if (k_ptr->sval == SV_STAFF_DETECT_TRAP) return (TRUE);
			if (k_ptr->sval == SV_STAFF_DETECT_DOOR) return (TRUE);
			if (k_ptr->sval == SV_STAFF_DETECT_GOLD) return (TRUE);
			if (k_ptr->sval == SV_STAFF_DETECT_ITEM) return (TRUE);
			if (k_ptr->sval == SV_STAFF_DETECT_INVIS) return (TRUE);
			if (k_ptr->sval == SV_STAFF_DETECT_EVIL) return (TRUE);
			if (k_ptr->sval == SV_STAFF_TELEPORTATION) return (TRUE);
			if (k_ptr->sval == SV_STAFF_IDENTIFY) return (TRUE);
			return (FALSE);
		}

	}

	/* Assume not suitable */
	return (FALSE);
}


/*
 * Hack -- determine if a template is suitable for the black_market.
 *
 * Note that this test only applies to the object *kind*, so it is
 * possible to cause the object to less valuable later.
 */
static bool kind_is_black_market(int k_idx)
{
	object_kind *k_ptr = &k_info[k_idx];

	/* First non-damaged weapons and armor are all good..... */
	switch (k_ptr->tval)
	{
		/* Armor -- Good unless damaged */
		case TV_HARD_ARMOR:
		case TV_SOFT_ARMOR:
		case TV_DRAG_ARMOR:
		case TV_DRAG_SHIELD:
		case TV_SHIELD:
		case TV_CLOAK:
		case TV_BOOTS:
		case TV_GLOVES:
		case TV_HELM:
		case TV_CROWN:
		{
			if (k_ptr->to_a < 0) return (FALSE);
			return (TRUE);
		}

		case TV_CHEST:
		{
			return (FALSE);
		}

		/* Weapons -- Good unless damaged */
		case TV_BOW:
		case TV_SWORD:
		case TV_HAFTED:
		case TV_POLEARM:
		case TV_DIGGING:
		case TV_BOLT:
		case TV_ARROW:
		case TV_SHOT:
		{
			if (k_ptr->to_h < 0) return (FALSE);
			if (k_ptr->to_d < 0) return (FALSE);
			return (TRUE);
		}
	}

	/* Otherwise -- No "cheap" base items */
	if (k_ptr->cost < 10) return (FALSE);

	/* Otherwise suitable at this point*/
	return (TRUE);
}

/*
 * Hack -- determine if a template is suitable for the magic_shop.
 *
 * Note that this test only applies to the object *kind*, so it is
 * possible to cause the object to be cursed.
 */
static bool kind_is_bookshop(int k_idx)
{
	object_kind *k_ptr = &k_info[k_idx];

	/* No "worthless" items */
	if (k_ptr->cost < 0) return (FALSE);

	/* Analyze the item type */
	switch (k_ptr->tval)
	{

		case TV_MAGIC_BOOK:
		case TV_PRAYER_BOOK:
		case TV_DRUID_BOOK:
		{
			if (allow_altered_inventory) return (TRUE);
			if (k_ptr->sval < SV_BOOK_MIN_GOOD) return (TRUE);
			return (FALSE);
		}

	}

	/* Assume not suitable */
	return (FALSE);
}

/*
 * Hack -- determine if a template is "a dungeon spellbook".
 *
 */
static bool kind_is_dungeon_spellbook(int k_idx)
{
	object_kind *k_ptr = &k_info[k_idx];

	/* Analyze the item type */
	switch (k_ptr->tval)
	{
		/* Books **/

		case TV_MAGIC_BOOK:
		case TV_DRUID_BOOK:
		case TV_PRAYER_BOOK:
		{
			if (k_ptr->sval >= SV_BOOK_MIN_GOOD) return (TRUE);
			return(FALSE);
		}

	}
	return(FALSE);

}

/*
 * Hack -- determine if a template is "a priestly dungeon prayerbook".
 */
static bool kind_is_dungeon_prayer_book(int k_idx)
{
	object_kind *k_ptr = &k_info[k_idx];

	/* Analyze the item type */
	switch (k_ptr->tval)
	{
		/* Books **/

		case TV_PRAYER_BOOK:
		{
			if (k_ptr->sval >= SV_BOOK_MIN_GOOD) return (TRUE);
			return(FALSE);
		}

	}
	return(FALSE);

}

/*
 * Hack -- determine if a template is "a druid dungeon spellbook".
 *
 */
static bool kind_is_dungeon_druid_book(int k_idx)
{
	object_kind *k_ptr = &k_info[k_idx];

	/* Analyze the item type */
	switch (k_ptr->tval)
	{
		/* Books **/

		case TV_DRUID_BOOK:
		{
			if (k_ptr->sval >= SV_BOOK_MIN_GOOD) return (TRUE);
			return(FALSE);
		}

	}
	return(FALSE);

}


/*
 * Hack -- determine if a template is "a mage dungeon spellbook".
 *
 */
static bool kind_is_dungeon_magic_book(int k_idx)
{
	object_kind *k_ptr = &k_info[k_idx];

	/* Analyze the item type */
	switch (k_ptr->tval)
	{
		/* Books **/

		case TV_MAGIC_BOOK:
		{
			if (k_ptr->sval >= SV_BOOK_MIN_GOOD) return (TRUE);
			return(FALSE);
		}

	}
	return (FALSE);
}


/*
 * Hack -- determine if a template is "great".
 *
 * Note that this test only applies to the object *kind*, so it is
 * possible to choose a kind which is "great", and then later cause
 * the actual object to be cursed.  We do explicitly forbid objects
 * which are known to be boring or which start out somewhat damaged.
 */
static bool kind_is_great(int k_idx)
{
	object_kind *k_ptr = &k_info[k_idx];

	/* Analyze the item type */
	switch (k_ptr->tval)
	{
		/* Armor -- great unless damaged */
		case TV_HARD_ARMOR:
		case TV_SOFT_ARMOR:
		case TV_DRAG_ARMOR:
		case TV_DRAG_SHIELD:
		case TV_SHIELD:
		case TV_CLOAK:
		case TV_BOOTS:
		case TV_GLOVES:
		case TV_HELM:
		case TV_CROWN:
		{
			if (k_ptr->to_a < 0) return (FALSE);
			return (TRUE);
		}

		/* Weapons -- great unless damaged */
		case TV_BOW:
		case TV_SWORD:
		case TV_HAFTED:
		case TV_POLEARM:
		{
			if (k_ptr->to_h < 0) return (FALSE);
			if (k_ptr->to_d < 0) return (FALSE);
			return (TRUE);
		}

		/* Ammo -- Arrows/Bolts are great, unless quest item */
		case TV_BOLT:
		case TV_ARROW:
		case TV_SHOT:
		{
			if ((object_generation_mode == OB_GEN_MODE_QUEST) ||
			    (object_generation_mode == OB_GEN_MODE_RANDART)) return (FALSE);
			return (TRUE);
		}

		/* Rings -- Rings of Speed are great */
		case TV_RING:
		{
			if (k_ptr->sval == SV_RING_SPEED) return (TRUE);
			return (FALSE);
		}

		/*scrolls of "*Acquirement*" are great*/
		case TV_SCROLL:
		{
			if (k_ptr->sval == SV_SCROLL_STAR_ACQUIREMENT) return (TRUE);
			if ((k_ptr->sval == SV_SCROLL_CREATE_RANDART) &&
			    (!adult_no_xtra_artifacts))   return (TRUE);
			return (FALSE);
		}

		/*
		 * Stat gain potions can be great at the lower levels.
		 */

		case TV_POTION:
		{
			switch (k_ptr->sval)
			{
				case SV_POTION_INC_STR:
				case SV_POTION_INC_INT:
				case SV_POTION_INC_WIS:
				case SV_POTION_INC_CON:
				case SV_POTION_INC_DEX:
				case SV_POTION_AUGMENTATION:
				{
					if (object_generation_mode != OB_GEN_MODE_QUEST) return (FALSE);

					if (object_level < (k_ptr->k_level - 5)) return (TRUE);
					return (FALSE);
				}
				default: break;
			}
			return (FALSE);
		}

		/* Chests -- Chests are great, except for quests.*/
		case TV_CHEST:
		{
			if ((object_generation_mode == OB_GEN_MODE_QUEST) ||
			    (object_generation_mode == OB_GEN_MODE_RANDART))  return (FALSE);
			return (TRUE);
		}
		default:  break;
	}

	/* Assume not great */
	return (FALSE);
}


/*
 * Hack -- determine if a template is a chest.
 *
 */
static bool kind_is_chest(int k_idx)
{
	object_kind *k_ptr = &k_info[k_idx];

	/* Analyze the item type */
	switch (k_ptr->tval)
	{
		/* Chests -- */
		case TV_CHEST:
		{
			return (TRUE);
		}

	}

	/* Assume not chest */
	return (FALSE);
}

/*
 * Hack -- determine if a template is footwear.
 *
 */
static bool kind_is_boots(int k_idx)
{
	object_kind *k_ptr = &k_info[k_idx];

	/* Analyze the item type */
	switch (k_ptr->tval)
	{
		/* footwear -- */
		case TV_BOOTS:
		{
			return (TRUE);
		}

	}

	/* Assume not footwear */
	return (FALSE);
}

/*
 * Hack -- determine if a template is headgear.
 *
 */
static bool kind_is_headgear(int k_idx)
{
	object_kind *k_ptr = &k_info[k_idx];

	/* Analyze the item type */
	switch (k_ptr->tval)
	{
		/* Headgear -- Suitable unless damaged */
		case TV_HELM:
		case TV_CROWN:
		{
			if (k_ptr->to_a < 0) return (FALSE);
			return (TRUE);
		}
	}

	/* Assume not headgear */
	return (FALSE);
}

/*
 * Hack -- determine if a template is wearable armor (all types).
 *
 */
static bool kind_is_armor(int k_idx)
{
	object_kind *k_ptr = &k_info[k_idx];

	/* Analyze the item type */
	switch (k_ptr->tval)
	{
		/* Armor -- suitable  unless damaged */
		case TV_HARD_ARMOR:
		case TV_SOFT_ARMOR:
		case TV_DRAG_ARMOR:
		case TV_DRAG_SHIELD:
		case TV_SHIELD:
		case TV_CLOAK:
		case TV_BOOTS:
		case TV_GLOVES:
		case TV_HELM:
		case TV_CROWN:
		{
			if (k_ptr->to_a < 0) return (FALSE);
			return (TRUE);
		}
	}

	/* Assume not armor */
	return (FALSE);
}

/*
 * Hack -- determine if a template is armor.
 *
 */
static bool kind_is_body_armor(int k_idx)
{
	object_kind *k_ptr = &k_info[k_idx];

	/* Analyze the item type */
	switch (k_ptr->tval)
	{
		/* Armor -- suitable  unless damaged */
		case TV_HARD_ARMOR:
		case TV_SOFT_ARMOR:
		case TV_DRAG_ARMOR:
		{
			if (k_ptr->to_a < 0) return (FALSE);
			return (TRUE);
		}
	}

	/* Assume not armor */
	return (FALSE);
}

/*
 * Hack -- determine if a template is Dragon Scale Mail or shield.
 *
 */
static bool kind_is_dragarmor(int k_idx)
{
	object_kind *k_ptr = &k_info[k_idx];

	/* Analyze the item type */
	switch (k_ptr->tval)
	{
		/* Dragon Armor -- suitable  unless damaged */
		case TV_DRAG_ARMOR:
		case TV_DRAG_SHIELD:
		{
			if (k_ptr->to_a < 0) return (FALSE);
			return (TRUE);
		}
	}

	/* Assume not Dragon Scale Mail */
	return (FALSE);
}

/*
 * Hack -- determine if a template is gloves.
 *
 */
static bool kind_is_gloves(int k_idx)
{
	object_kind *k_ptr = &k_info[k_idx];

	/* Analyze the item type */
	switch (k_ptr->tval)
	{
		/* Gloves -- suitable  unless damaged */
		case TV_GLOVES:
		{
			if (k_ptr->to_a < 0) return (FALSE);
			return (TRUE);
		}
	}

	/* Assume not suitable  */
	return (FALSE);
}

/*
 * Hack -- determine if a template is a cloak.
 *
 */
static bool kind_is_cloak(int k_idx)
{
	object_kind *k_ptr = &k_info[k_idx];

	/* Analyze the item type */
	switch (k_ptr->tval)
	{
		/* Cloaks -- suitable  unless damaged */

		case TV_CLOAK:
		{
			if (k_ptr->to_a < 0) return (FALSE);
			return (TRUE);
		}
	}

	/* Assume not a suitable  */
	return (FALSE);
}

/*
 * Hack -- determine if a template is a shield.
 *
 */
static bool kind_is_shield(int k_idx)
{
	object_kind *k_ptr = &k_info[k_idx];

	/* Analyze the item type */
	switch (k_ptr->tval)
	{
		/* shield -- suitable  Unless Damaged*/
		case TV_SHIELD:
		case TV_DRAG_SHIELD:
		{
			if (k_ptr->to_a < 0) return (FALSE);
			return (TRUE);
		}

	}

	/* Assume not suitable */
	return (FALSE);
}

/*
 * Hack -- determine if a template is a bow/ammo.
 */

static bool kind_is_bow(int k_idx)
{
	object_kind *k_ptr = &k_info[k_idx];

	/* Analyze the item type */
	switch (k_ptr->tval)
	{

		/* All firing weapons and Ammo are suitable  */
		case TV_BOW:
		{
			return (TRUE);
		}

		/*hack - don't allow ammo as a quest reward*/
		case TV_BOLT:
		case TV_ARROW:
		case TV_SHOT:
		{
			if ((object_generation_mode == OB_GEN_MODE_QUEST) ||
			    (object_generation_mode == OB_GEN_MODE_RANDART))  return (FALSE);
			return (TRUE);

		}

	}

	/* Assume not suitable  */
	return (FALSE);
}


/*
 * Hack -- determine if a template is a hafted weapon.
 */

static bool kind_is_hafted(int k_idx)
{
	object_kind *k_ptr = &k_info[k_idx];

	/* Analyze the item type */
	switch (k_ptr->tval)
	{
		/* Hafted Weapons -- suitable  unless damaged */
		case TV_HAFTED:
		{
			if (k_ptr->to_h < 0) return (FALSE);
			if (k_ptr->to_d < 0) return (FALSE);
			return (TRUE);
		}
	}

	/* Assume not suitable  */
	return (FALSE);
}

/*
 * Hack -- determine if a template is a "good" digging tool
 *
 */
static bool kind_is_digging_tool(int k_idx)
{
	object_kind *k_ptr = &k_info[k_idx];

	/* Analyze the item type */
	switch (k_ptr->tval)
	{

		/* Diggers -- Good unless damaged */
		case TV_DIGGING:
		{
			if (k_ptr->to_h < 0) return (FALSE);
			if (k_ptr->to_d < 0) return (FALSE);
			return (TRUE);
		}

	}

	/* Assume not good */
	return (FALSE);
}

/*
 * Hack -- determine if a template is a edged weapon.
 */
static bool kind_is_edged(int k_idx)
{
	object_kind *k_ptr = &k_info[k_idx];

	/* Analyze the item type */
	switch (k_ptr->tval)
	{
		/* Edged Weapons -- suitable unless damaged */
		case TV_SWORD:
		{
			if (k_ptr->to_h < 0) return (FALSE);
			if (k_ptr->to_d < 0) return (FALSE);
			return (TRUE);
		}
	}

	/* Assume not suitable */
	return (FALSE);
}

/*
 * Hack -- determine if a template is a polearm.
 */
static bool kind_is_polearm(int k_idx)
{
	object_kind *k_ptr = &k_info[k_idx];

	/* Analyze the item type */
	switch (k_ptr->tval)
	{
		/* Weapons -- suitable  unless damaged */
		case TV_POLEARM:
		{
			if (k_ptr->to_h < 0) return (FALSE);
			if (k_ptr->to_d < 0) return (FALSE);
			return (TRUE);
		}
	}

	/* Assume not suitable */
	return (FALSE);
}

/*
 * Hack -- determine if a template is a weapon.
 */
static bool kind_is_weapon(int k_idx)
{
	object_kind *k_ptr = &k_info[k_idx];

	/* Analyze the item type */
	switch (k_ptr->tval)
	{
		/* Weapons -- suitable  unless damaged */
		case TV_SWORD:
		case TV_HAFTED:
		case TV_POLEARM:
		{
			if (k_ptr->to_h < 0) return (FALSE);
			if (k_ptr->to_d < 0) return (FALSE);
			return (TRUE);
		}
	}

	/* Assume not suitable */
	return (FALSE);
}

/*
 * Hack -- determine if a scroll is suitable for a chest.
 *
 */
static bool kind_is_scroll(int k_idx)
{
	object_kind *k_ptr = &k_info[k_idx];

	/* Analyze the item type */
	switch (k_ptr->tval)
	{

		/*scrolls suitable for a chest*/
		case TV_SCROLL:
		{
			if (k_ptr->sval == SV_SCROLL_ACQUIREMENT) return (TRUE);
			if ((k_ptr->sval == SV_SCROLL_CREATE_RANDART) &&
			    (!adult_no_xtra_artifacts))   return (TRUE);
			if (k_ptr->sval == SV_SCROLL_STAR_ACQUIREMENT) return (TRUE);
			if (k_ptr->sval == SV_SCROLL_BANISHMENT) return (TRUE);
			if (k_ptr->sval == SV_SCROLL_MASS_BANISHMENT) return (TRUE);
			if (k_ptr->sval == SV_SCROLL_RUNE_OF_PROTECTION) return (TRUE);
			if ((k_ptr->sval == SV_SCROLL_TELEPORT) &&
				((k_ptr->k_level + 15) >= object_level )) return (TRUE);
			if (k_ptr->sval == SV_SCROLL_STAR_IDENTIFY) return (TRUE);
			if ((k_ptr->sval == SV_SCROLL_RECHARGING) &&
				((k_ptr->k_level + 15) >= object_level )) return (TRUE);
			if (k_ptr->sval == SV_SCROLL_STAR_RECHARGING) return (TRUE);
			if (k_ptr->sval == SV_SCROLL_CREATE_MONSTER_TRAP) return (TRUE);

			return (FALSE);
		}

		/* Books -- HACK - High level books are good only
		 * if within 5 levels of being out of depth */
		case TV_MAGIC_BOOK:
		case TV_PRAYER_BOOK:
		case TV_DRUID_BOOK:
		{
			if (((k_ptr->k_level - 5) < object_level ) &&
			(k_ptr->sval >= SV_BOOK_MIN_GOOD)) return (TRUE);
			return (FALSE);
		}

	}

	/* Assume not suitable */
	return (FALSE);
}

/*
 * Hack -- determine if a potion is good for a chest.
 * includes mushroom of restoring
 *
 */
static bool kind_is_potion(int k_idx)
{
	object_kind *k_ptr = &k_info[k_idx];

	/* Analyze the item type */
	switch (k_ptr->tval)
	{

		/*potions suitable for a chest*/
		case TV_POTION:
		{
			if (k_ptr->sval == SV_POTION_SPEED) return (TRUE);
			if ((k_ptr->sval == SV_POTION_HEALING) &&
				((k_ptr->k_level + 20) >= object_level )) return (TRUE);
			if (k_ptr->sval == SV_POTION_STAR_HEALING) return (TRUE);
			if (k_ptr->sval == SV_POTION_LIFE) return (TRUE);
			if ((k_ptr->sval == SV_POTION_INC_STR) &&
				((k_ptr->k_level + 10) >= object_level )) return (TRUE);
			if ((k_ptr->sval == SV_POTION_INC_INT) &&
				((k_ptr->k_level + 10) >= object_level )) return (TRUE);
			if ((k_ptr->sval == SV_POTION_INC_WIS) &&
				((k_ptr->k_level + 10) >= object_level )) return (TRUE);
			if ((k_ptr->sval == SV_POTION_INC_DEX) &&
				((k_ptr->k_level + 10) >= object_level )) return (TRUE);
			if ((k_ptr->sval == SV_POTION_INC_CON) &&
				((k_ptr->k_level + 10) >= object_level )) return (TRUE);
			if ((k_ptr->sval == SV_POTION_INC_CHR) &&
				((k_ptr->k_level + 10) >= object_level )) return (TRUE);
			if ((k_ptr->sval == SV_POTION_AUGMENTATION) &&
				((k_ptr->k_level + 10) >= object_level )) return (TRUE);
			if (k_ptr->sval == SV_POTION_EXPERIENCE) return (TRUE);
			if (k_ptr->sval == SV_POTION_ENLIGHTENMENT) return (TRUE);
			if (k_ptr->sval == SV_POTION_RESISTANCE) return (TRUE);

			return (FALSE);
		}

		case TV_FOOD:
		/* HACK -  Mushrooms of restoring can be with potions */
		{
			if ((k_ptr->sval == SV_FOOD_RESTORING) &&
				((k_ptr->k_level + 25) >= object_level )) return (TRUE);
			return (FALSE);
		}

	}

	/* Assume not suitable */
	return (FALSE);
}

/*
 * Hack -- determine if a rod/wand/staff is good for a chest.
 *
 */
static bool kind_is_rod_wand_staff(int k_idx)
{
	object_kind *k_ptr = &k_info[k_idx];

	/* Analyze the item type */
	switch (k_ptr->tval)
	{

		/*wands suitable for a chest*/
		case TV_WAND:

		{
			if ((k_ptr->sval == SV_WAND_TELEPORT_AWAY) &&
				((k_ptr->k_level + 20) >= object_level )) return (TRUE);
			if ((k_ptr->sval == SV_WAND_STONE_TO_MUD) &&
				((k_ptr->k_level + 20) >= object_level )) return (TRUE);
			if (k_ptr->sval == SV_WAND_ANNIHILATION) return (TRUE);
			if (k_ptr->sval == SV_WAND_DRAGON_FIRE) return (TRUE);
			if (k_ptr->sval == SV_WAND_DRAGON_COLD) return (TRUE);
			if (k_ptr->sval == SV_WAND_DRAGON_BREATH) return (TRUE);

			return (FALSE);

		}

		/*staffs suitable for a chest*/
		case TV_STAFF:

		{
			if ((k_ptr->sval == SV_STAFF_TELEPORTATION) &&
				((k_ptr->k_level + 20) >= object_level )) return (TRUE);
			if (k_ptr->sval == SV_STAFF_THE_MAGI) return (TRUE);
			if (k_ptr->sval == SV_STAFF_SPEED) return (TRUE);
			if (k_ptr->sval == SV_STAFF_DISPEL_EVIL) return (TRUE);
			if (k_ptr->sval == SV_STAFF_POWER) return (TRUE);
			if (k_ptr->sval == SV_STAFF_HOLINESS) return (TRUE);
			if (k_ptr->sval == SV_STAFF_BANISHMENT) return (TRUE);
			if (k_ptr->sval == SV_STAFF_MASS_IDENTIFY) return (TRUE);
			if ((k_ptr->sval == SV_STAFF_DESTRUCTION) &&
				((k_ptr->k_level + 20) >= object_level )) return (TRUE);
			return (FALSE);
		}

		/*rods suitable for a chest*/
		case TV_ROD:

		{
			if ((k_ptr->sval == SV_ROD_IDENTIFY) &&
				((k_ptr->k_level + 20) >= object_level )) return (TRUE);
			if ((k_ptr->sval == SV_ROD_DETECTION) &&
				((k_ptr->k_level + 20) >= object_level )) return (TRUE);
			if ((k_ptr->sval == SV_ROD_STONE_TO_MUD) &&
				((k_ptr->k_level + 10) >= object_level )) return (TRUE);
			if (k_ptr->sval == SV_ROD_HEALING) return (TRUE);
			if (k_ptr->sval == SV_ROD_RESTORATION) return (TRUE);
			if (k_ptr->sval == SV_ROD_SPEED) return (TRUE);
			if (k_ptr->sval == SV_ROD_STAR_IDENTIFY) return (TRUE);
			if (k_ptr->sval == SV_ROD_MASS_IDENTIFY) return (TRUE);
			if ((k_ptr->sval == SV_ROD_TELEPORT_AWAY) &&
				((k_ptr->k_level + 20) >= object_level )) return (TRUE);
			return (FALSE);
		}

	}

	/* Assume not suitable for a chest */
	return (FALSE);
}

/*
 * Hack -- determine if a template is "jewelry for chests".
 *
 */
static bool kind_is_jewelry(int k_idx)
{
	object_kind *k_ptr = &k_info[k_idx];

	/* Analyze the item type */
	switch (k_ptr->tval)
	{
		/* Crowns are suitable for a chest */
		case TV_CROWN:
		{
			if (k_ptr->to_a < 0) return (FALSE);
			return (TRUE);
		}

		/*  Rings of Speed are suitable for a chest */
		case TV_RING:
		{
			if (k_ptr->sval == SV_RING_SPEED) return (TRUE);
			return (FALSE);
		}

		/* Some Amulets are suitable for a chest*/
		case TV_AMULET:

		{
		  	if (k_ptr->sval == SV_AMULET_THE_MAGI) return (TRUE);
			if (k_ptr->sval == SV_AMULET_DEVOTION) return (TRUE);
			if (k_ptr->sval == SV_AMULET_WEAPONMASTERY) return (TRUE);
			if (k_ptr->sval == SV_AMULET_TRICKERY) return (TRUE);
			return (FALSE);
		}

	}

	/* Assume not suitable for a chest */
	return (FALSE);
}





/*
 * Hack -- determine if a template is "good".
 *
 * Note that this test only applies to the object *kind*, so it is
 * possible to choose a kind which is "good", and then later cause
 * the actual object to be cursed.  We do explicitly forbid objects
 * which are known to be boring or which start out somewhat damaged.
 */
static bool kind_is_good(int k_idx)
{
	object_kind *k_ptr = &k_info[k_idx];

	/* Analyze the item type */
	switch (k_ptr->tval)
	{
		/* Armor -- Good unless damaged */
		case TV_HARD_ARMOR:
		case TV_SOFT_ARMOR:
		case TV_DRAG_ARMOR:
		case TV_DRAG_SHIELD:
		case TV_SHIELD:
		case TV_CLOAK:
		case TV_BOOTS:
		case TV_GLOVES:
		case TV_HELM:
		case TV_CROWN:
		{
			if (k_ptr->to_a < 0) return (FALSE);
			return (TRUE);
		}

		/* Weapons -- Good unless damaged */
		case TV_BOW:
		case TV_SWORD:
		case TV_HAFTED:
		case TV_POLEARM:
		case TV_DIGGING:
		{
			if (k_ptr->to_h < 0) return (FALSE);
			if (k_ptr->to_d < 0) return (FALSE);
			return (TRUE);
		}

		/* Ammo -- Arrows/Bolts are good */
		case TV_BOLT:
		case TV_ARROW:
		case TV_SHOT:
		{
			if ((object_generation_mode == OB_GEN_MODE_QUEST) ||
			    (object_generation_mode == OB_GEN_MODE_RANDART))  return (FALSE);
			return (TRUE);
		}

		/* Books -- HACK - High level books are good only
		 * if within 15 levels of being out of depth
		 **/

		case TV_MAGIC_BOOK:
		case TV_PRAYER_BOOK:
		case TV_DRUID_BOOK:
		{
			if (((k_ptr->k_level - 15) < object_level ) &&
			(k_ptr->sval >= SV_BOOK_MIN_GOOD)) return (TRUE);
			return (FALSE);
		}

		/* Rings -- Rings of Speed are good */
		case TV_RING:
		{
			if (k_ptr->sval == SV_RING_SPEED) return (TRUE);
			return (FALSE);
		}

		/* Amulets -- Amulets are good*/
		case TV_AMULET:

		{
		  	if (k_ptr->sval == SV_AMULET_THE_MAGI) return (TRUE);
			if (k_ptr->sval == SV_AMULET_DEVOTION) return (TRUE);
			if (k_ptr->sval == SV_AMULET_WEAPONMASTERY) return (TRUE);
			if (k_ptr->sval == SV_AMULET_TRICKERY) return (TRUE);
			return (FALSE);
		}

		/*scrolls of "*acquirement*" and "acquirement" are good*/
		case TV_SCROLL:

		{
			if (k_ptr->sval == SV_SCROLL_ACQUIREMENT) return (TRUE);
			if (k_ptr->sval == SV_SCROLL_STAR_ACQUIREMENT) return (TRUE);
			if ((k_ptr->sval == SV_SCROLL_CREATE_RANDART) &&
			    (!adult_no_xtra_artifacts))   return (TRUE);
			return (FALSE);
		}

		/*
		 * The very powerful healing potions can be good.
		 * Stat gain potions can be good at the lower levels.
		 */
		case TV_POTION:
		{
			switch (k_ptr->sval)
			{
				case SV_POTION_STAR_HEALING:
				case SV_POTION_LIFE:
				{
					if (object_level > 85) return (TRUE);
					return (FALSE);
				}
				case SV_POTION_INC_STR:
				case SV_POTION_INC_INT:
				case SV_POTION_INC_WIS:
				case SV_POTION_INC_CON:
				case SV_POTION_INC_DEX:
				case SV_POTION_AUGMENTATION:
				{
					if (object_generation_mode != OB_GEN_MODE_QUEST) return (FALSE);

					if (object_level < (k_ptr->k_level - 5)) return (TRUE);
					return (FALSE);
				}
				default: break;

			}
			return (FALSE);
		}

		/* Chests -- Chests are good. */
		case TV_CHEST:
		{
			return (TRUE);
		}

	}

	/* Assume not good */
	return (FALSE);
}

void object_quantities(object_type *j_ptr)
{
	/* Hack -- generate multiple spikes/missiles */
	switch (j_ptr->tval)
	{
		case TV_SPIKE:
		case TV_SHOT:
		case TV_ARROW:
		case TV_BOLT:
		{
			j_ptr->number = damroll(6, 7);
			return;
		}
		/* Occasionally do multiple potions, scrolls */
		case TV_SCROLL:
		case TV_POTION:
		{
			if (one_in_(10)) j_ptr->number = randint1(2);
			return;
		}
		case TV_FOOD:
		{
			if (one_in_(5)) j_ptr->number = damroll(2,2);
			return;
		}

	}
}



/*
 * Attempt to make an object (normal or good/great)
 *
 * This routine plays nasty games to generate the "special artifacts".
 *
 * This routine uses "object_level" for the "generation level".
 *
 * We assume that the given object has been "wiped".
 */
bool make_object(object_type *j_ptr, bool good, bool great, int objecttype, bool interesting)
{
	int prob, base;

	/* Chance of "special object" */
	prob = ((good || great) ? 10 : 1000);

	/*better chance to check special artifacts if there is a jewelry theme*/
	if (objecttype == DROP_TYPE_JEWELRY) prob /= 2;

	/* Base level for the object */
	base = ((good || great) ? (object_level + 10) : object_level);

	/* Give only interesting items*/
	if (interesting)
	{
		get_obj_num_hook = kind_is_good;
	}

	/* Attempt to generate a special artifact if prob = 0, or a normal object
	 * if not.
	 */
	if ((rand_int(prob) != 0) || (!make_artifact_special(j_ptr)))
	{
		int k_idx;

		/*
		 * Next check if it is a themed drop, and
		 * only include objects from a pre-set theme.  But, it can be
		 * called from anywhere.
		 * First check to skip all these checks when unnecessary.
		 */
		 if ((good) || (great) || (objecttype >= DROP_TYPE_POTION))
		{
			/*note - theme 1 is gold, sent to the make_gold function*/
			if (objecttype == DROP_TYPE_POTION)						get_obj_num_hook = kind_is_potion;
			else if (objecttype == DROP_TYPE_ROD_WAND_STAFF) 		get_obj_num_hook = kind_is_rod_wand_staff;
			else if (objecttype == DROP_TYPE_SCROLL) 				get_obj_num_hook = kind_is_scroll;
			else if (objecttype == DROP_TYPE_SHIELD) 				get_obj_num_hook = kind_is_shield;
			else if (objecttype == DROP_TYPE_WEAPON) 				get_obj_num_hook = kind_is_weapon;
			else if (objecttype == DROP_TYPE_ARMOR) 				get_obj_num_hook = kind_is_body_armor;
			else if (objecttype == DROP_TYPE_BOOTS) 				get_obj_num_hook = kind_is_boots;
			else if (objecttype == DROP_TYPE_BOW) 					get_obj_num_hook = kind_is_bow;
			else if (objecttype == DROP_TYPE_CLOAK)					get_obj_num_hook = kind_is_cloak;
			else if (objecttype == DROP_TYPE_GLOVES)				get_obj_num_hook = kind_is_gloves;
			else if (objecttype == DROP_TYPE_HAFTED)				get_obj_num_hook = kind_is_hafted;
			else if (objecttype == DROP_TYPE_HEADGEAR)				get_obj_num_hook = kind_is_headgear;
			else if (objecttype == DROP_TYPE_JEWELRY)				get_obj_num_hook = kind_is_jewelry;
			else if (objecttype == DROP_TYPE_DRAGON_ARMOR)			get_obj_num_hook = kind_is_dragarmor;
			else if (objecttype == DROP_TYPE_CHEST)					get_obj_num_hook = kind_is_chest;
			else if (objecttype == DROP_TYPE_DUNGEON_MAGIC_BOOK)	get_obj_num_hook = kind_is_dungeon_magic_book;
			else if (objecttype == DROP_TYPE_DUNGEON_PRAYER_BOOK)	get_obj_num_hook = kind_is_dungeon_prayer_book;
			else if (objecttype == DROP_TYPE_DUNGEON_DRUID_BOOK)	get_obj_num_hook = kind_is_dungeon_druid_book;
			else if (objecttype == DROP_TYPE_EDGED)					get_obj_num_hook = kind_is_edged;
			else if (objecttype == DROP_TYPE_POLEARM)				get_obj_num_hook = kind_is_polearm;
			else if (objecttype == DROP_TYPE_DIGGING)				get_obj_num_hook = kind_is_digging_tool;

			/*
			 *	If it isn't a chest, check good and great flags.
			 *  They each now have their own templates.
			 */
			else if (great)	get_obj_num_hook = kind_is_great;
			else if (good)	get_obj_num_hook = kind_is_good;
		}

		/* Prepare allocation table if needed*/
		if ((objecttype) || (good) || (great) || (interesting))
		{
			get_obj_num_prep();
		}

		/* Pick a random object */
		k_idx = get_obj_num(base);

		/* Clear the objects template*/
		if ((objecttype) ||	(good) || (great) || (interesting))
		{
			/* Clear restriction */
			get_obj_num_hook = NULL;

			/* Prepare allocation table */
			get_obj_num_prep();
		}


		/* Handle failure*/
		if (!k_idx) return (FALSE);

		/* Prepare the object */
		object_prep(j_ptr, k_idx);

	}

	/* Apply magic (allow artifacts) */
	apply_magic(j_ptr, object_level, TRUE, good, great, interesting);

	/* Hack -- generate multiple objects occasionally */
	object_quantities(j_ptr);

	/* Notice "okay" out-of-depth objects */
	if (!cursed_p(j_ptr) && !broken_p(j_ptr) &&
	    (k_info[j_ptr->k_idx].k_level > effective_depth(p_ptr->depth)))
	{
		/* Rating increase */
		rating += (k_info[j_ptr->k_idx].k_level - effective_depth(p_ptr->depth));

		/* Cheat -- peek at items */
		if (cheat_peek) object_mention(j_ptr);
	}

	/* Success */
	return (TRUE);
}

/*
 * Sets the object generation mode for the store, since in doing
 * store inventory we make many objects of the same type
 * The function is here rather than store.c because
 * This is where all the other needed functions are.
 */

bool prep_store_object(int storetype)
{
	/*get the store creation mode*/
	switch (storetype)
	{
		case STORE_GENERAL:
		{
			object_generation_mode = OB_GEN_MODE_GEN_ST;
			if (game_mode == GAME_NPPMORIA) get_obj_num_hook = kind_is_gen_store_moria;
			else get_obj_num_hook = kind_is_gen_store;
			break;
		}
		case STORE_ARMOR:
		{
			object_generation_mode = OB_GEN_MODE_ARMOURY;
			if (game_mode == GAME_NPPMORIA) get_obj_num_hook = kind_is_armoury_moria;
			else get_obj_num_hook = kind_is_armoury;
			break;
		}
		case STORE_WEAPON:
		{
			object_generation_mode = OB_GEN_MODE_WEAPONSMITH;
			if (game_mode == GAME_NPPMORIA) get_obj_num_hook = kind_is_weaponsmith_moria;
			else get_obj_num_hook = kind_is_weaponsmith;
			break;
		}
		case STORE_TEMPLE:
		{
			object_generation_mode = OB_GEN_MODE_TEMPLE;
			if (game_mode == GAME_NPPMORIA) get_obj_num_hook = kind_is_temple_moria;
			else get_obj_num_hook = kind_is_temple;
			break;
		}
		case STORE_ALCHEMY:
		{
			object_generation_mode = OB_GEN_MODE_ALCHEMY;
			if (game_mode == GAME_NPPMORIA) get_obj_num_hook = kind_is_alchemy_moria;
			else get_obj_num_hook = kind_is_alchemy;
			break;
		}
		case STORE_MAGIC:
		{
			object_generation_mode = OB_GEN_MODE_MAGIC_SHOP;
			if (game_mode == GAME_NPPMORIA) get_obj_num_hook = kind_is_magic_shop_moria;
			else get_obj_num_hook = kind_is_magic_shop;
			break;
		}
		case STORE_B_MARKET:
		{
			object_generation_mode = OB_GEN_MODE_BLACK_MARK;
			get_obj_num_hook = kind_is_black_market;
			break;
		}
		case STORE_BOOKSHOP:
		{
			object_generation_mode = OB_GEN_MODE_BOOKSHOP;
			get_obj_num_hook = kind_is_bookshop;
			break;
		}

		default: return (FALSE);
	}

	/*prepare the allocation table*/
	get_obj_num_prep();

	return(TRUE);

}

/*
 * Set the object theme
 */


/*
 * This is an imcomplete list of themes.  Returns false if theme not found.
 * Used primarily for Randarts
 */
bool prep_object_theme(int themetype)
{
	/*get the store creation mode*/
	switch (themetype)
	{
		case DROP_TYPE_SHIELD:
		{
			get_obj_num_hook = kind_is_shield;
			break;
		}
		case DROP_TYPE_WEAPON:
		{
			get_obj_num_hook = kind_is_weapon;
			break;
		}
		case DROP_TYPE_EDGED:
		{
			get_obj_num_hook = kind_is_edged;
			break;
		}
		case DROP_TYPE_POLEARM:
		{
			get_obj_num_hook = kind_is_polearm;
			break;
		}
		case DROP_TYPE_ARMOR:
		{
			get_obj_num_hook = kind_is_body_armor;
			break;
		}
		case DROP_TYPE_BOOTS:
		{
			get_obj_num_hook = kind_is_boots;
			break;
		}
		case DROP_TYPE_BOW:
		{
			get_obj_num_hook = kind_is_bow;
			break;
		}
		case DROP_TYPE_CLOAK:
		{
			get_obj_num_hook = kind_is_cloak;
			break;
		}
		case DROP_TYPE_GLOVES:
		{
			get_obj_num_hook = kind_is_gloves;
			break;
		}
		case DROP_TYPE_HAFTED:
		{
			get_obj_num_hook = kind_is_hafted;
			break;
		}
		case DROP_TYPE_HEADGEAR:
		{
			get_obj_num_hook = kind_is_headgear;
			break;
		}
		case DROP_TYPE_DRAGON_ARMOR:
		{
			get_obj_num_hook = kind_is_dragarmor;
			break;
		}
		case DROP_TYPE_DIGGING:
		{
			get_obj_num_hook = kind_is_digging_tool;

			break;
		}

		default: return (FALSE);
	}

	/*prepare the allocation table*/
	get_obj_num_prep();

	return(TRUE);

}


/*
 * Get the mimic k_idx for certain objects.
 */
int get_object_mimic_k_idx(const monster_race *r_ptr)
{
	int k_idx = 0;

	if (r_ptr->d_char == ')') get_obj_num_hook = kind_is_armor;
	else if (r_ptr->d_char == '|') get_obj_num_hook = kind_is_weapon;
	else if (r_ptr->d_char == '?') get_obj_num_hook = kind_is_dungeon_spellbook;
	else if (r_ptr->d_char == '[') get_obj_num_hook = kind_is_dragarmor;
	/* Whoops! */
	else return (0);

	/* Prepare allocation table */
	get_obj_num_prep();

	/* Find an object to mimic */
	while (!k_idx) k_idx = get_obj_num(effective_depth(p_ptr->depth));

	/* Clear restriction */
	get_obj_num_hook = NULL;

	/* Prepare allocation table */
	get_obj_num_prep();

	return(k_idx);

}


/*
 * Make a treasure object
 *
 * The location must be a legal, clean, floor grid.
 */
bool make_gold(object_type *j_ptr)
{
	int sval;
	int k_idx;
	s32b base;
	s32b value;
	s32b mult = (birth_no_selling ? object_level : 1);

	/* Boundry control for gold multiplier birth_no_selling option*/
	if (mult < 1) 		mult = 1;
	else if (mult > 5) 	mult = 5;

	/* Hack -- Pick a Treasure variety */
	sval = ((randint(object_level + 2) + 2) / 2);

	/* Apply "extra" magic */
	if (one_in_(GREAT_OBJ))
	{
		sval += randint(object_level + 1);
	}

	/* Hack -- Creeping Coins only generate "themselves" */
	if (coin_type) sval = coin_type;

	/* Do not create "illegal" Treasure Types */
	if (sval > MAX_GOLD) sval = MAX_GOLD;

	k_idx = lookup_kind(TV_GOLD, sval);

	/* Prepare a gold object */
	object_prep(j_ptr, k_idx);

	/* Hack -- Base coin cost */
	base = k_info[k_idx].cost * mult;

	/* Determine how much the treasure is "worth" */
	value = (base + (8L * randint(base)) + randint((8 * mult)));

	/*chests containing gold are very lucrative*/
	if (object_generation_mode > 0)
	{
		value += ((randint((4 * mult)) + randint((4 * mult)) + object_level / 4 ) * 50);
	}

	/* Cap gold at max short (or alternatively make pvals s32b) */
	if (value > MAX_SHORT)	value = MAX_SHORT;

	j_ptr->pval = value;

	/* Success */
	return (TRUE);
}





/*
 * Attempt to place an object (normal or good/great) at the given location.
 */
void place_object(int y, int x, bool good, bool great, int droptype)
{
	int tries = 0;


	object_type *i_ptr;
	object_type object_type_body;

	/* Paranoia */
	if (!in_bounds(y, x)) return;

	/* Hack -- clean floor space */
	if (!cave_clean_bold(y, x)) return;

	/* Get local object */
	i_ptr = &object_type_body;

	/* Make an object (if possible) */
	while (TRUE)
	{
		/* Avoid infinite loops */
		if (++tries > 100) return;

 		/* Wipe the object */
 		object_wipe(i_ptr);

		/* Create the object */
		if (!make_object(i_ptr, good, great, droptype, FALSE)) continue;

		/* Check compatibility with terrain */
		if (object_hates_location(y, x, i_ptr))
		{
			/* Hack -- Preserve artifacts */
			a_info[i_ptr->art_num].a_cur_num = 0;

			/* Try again */
			continue;
		}

		/* We have a suitable object */
		break;
	}

	/* Remember history */
	object_history(i_ptr, ORIGIN_FLOOR, 0);

 	/* Give it to the floor */
 	if (!floor_carry(y, x, i_ptr))

	{
		/* Hack -- Preserve artifacts */
		a_info[i_ptr->art_num].a_cur_num = 0;
	}
}

/*
 * Attempt to place a quest artifact at the given location.
 */
bool place_quest_artifact(int y, int x)
{
	object_type object_type_body;
	object_type *i_ptr = &object_type_body;;

	/* Paranoia */
	if (!in_bounds(y, x)) return (FALSE);

	/* Hack -- clean floor space */
	if (!cave_clean_bold(y, x)) return (FALSE);

	/* Already created */
	if (a_info[QUEST_ART_SLOT].a_cur_num) return (FALSE);

	/* Wipe the object */
	object_wipe(i_ptr);

	/* Make a quest artifact (should never fail) */
	create_quest_artifact(i_ptr);

	/* Give it to the floor */
	if (!floor_carry(y, x, i_ptr)) return (FALSE);

	/* Success */
	return (TRUE);

}

/*
 * Places a treasure (Gold or Gems) at given location
 */
void place_gold(int y, int x)
{
	object_type *i_ptr;
	object_type object_type_body;

	/* Paranoia */
	if (!in_bounds(y, x)) return;

	/* Require clean floor space */
	if (!cave_clean_bold(y, x)) return;

	/* Get local object */
	i_ptr = &object_type_body;

	/* Wipe the object */
	object_wipe(i_ptr);

	/* Make some gold */
	if (make_gold(i_ptr))
	{
		/* Give it to the floor */
		(void)floor_carry(y, x, i_ptr);
	}
}







/* Steal from monster and make an object in the player inventory.
 * This whole function is basically an abbreviated object creation
 * routine.  Much of the object creation code can't be called because
 * they all assume the object is destined for either the stores or
 * the dungeon floor.  This item is being created and handed directly
 * to the player.  We must create the item, give gold to
 * the player or create an item, update the lore, check if autosquelch
 * is appropriate, make sure no artifacts are squelched, place the item directly
 * in the player's inventory, if there is room.  If not, drop it to the
 * floor, and finally, wipe the object. -JG
 */


void steal_object_from_monster(int y, int x)
{
	monster_type *m_ptr = &mon_list[cave_m_idx[y][x]];
	monster_race *r_ptr = &r_info[m_ptr->r_idx];
	char o_name[80];

	bool chest = (r_ptr->flags1 & (RF1_DROP_CHEST)) ? TRUE : FALSE;
	bool good = (r_ptr->flags1 & (RF1_DROP_GOOD)) ? TRUE : FALSE;
	bool great = (r_ptr->flags1 & (RF1_DROP_GREAT)) ? TRUE : FALSE;

	bool do_gold = (!(r_ptr->flags1 & (RF1_ONLY_ITEM)));
	bool do_item = (!(r_ptr->flags1 & (RF1_ONLY_GOLD)));

	object_type *i_ptr;
	object_type object_type_body;

	/* Average dungeon and monster levels */
	object_level = (effective_depth(p_ptr->depth) + r_ptr->level) / 2;

	/* Get local object */
	i_ptr = &object_type_body;

	/* Wipe the object */
	object_wipe(i_ptr);

	/* Make Gold */
	if (do_gold && (!chest) && (!do_item || (rand_int(100) < 50)))
	{

		/*get coin type "flavor" if appropriate*/
		coin_type = get_coin_type(r_ptr);

		/* Make some gold */
		while (!make_gold(i_ptr)) continue;

		/* Describe the object */
		object_desc(o_name, sizeof(o_name), i_ptr, ODESC_PREFIX | ODESC_FULL);

		/* Message */
		msg_format("You have stolen %ld gold pieces worth of %s.",
			           (long)i_ptr->pval, o_name);

		/* Collect the gold */
		p_ptr->au += i_ptr->pval;

		/* Delete the gold */
		object_wipe(i_ptr);

		/* Redraw gold */
		p_ptr->redraw |= (PR_GOLD);

		/*update the monster lore*/
		lore_treasure(cave_m_idx[y][x], 0, 1);

		/* Reset "coin" type */
		coin_type = 0;

	}

	/* Make Object */
	else
	{
		bool sq_flag = FALSE;

		/*Make an object, but make a chest if that is the theme*/
		if (chest)
		{
			while (!make_object(i_ptr, good, great, DROP_TYPE_CHEST, FALSE)) continue;

			/*clear the allocation table when done*/
		}

		/* Make an object */
		else while (!make_object(i_ptr, good, great,DROP_TYPE_UNTHEMED, FALSE)) continue;

		/* Describe the object */
		object_desc(o_name, sizeof(o_name), i_ptr, ODESC_PREFIX | ODESC_FULL);

		/*update the monster lore*/
		lore_treasure(cave_m_idx[y][x], 1, 0);

		/*does the player want to squelch the item?*/
		sq_flag = ((k_info[i_ptr->k_idx].squelch == SQUELCH_ALWAYS) &&
 				   (k_info[i_ptr->k_idx].aware));

		if (!sq_flag)
		{
			/* Note that the pack is too full */
			if (!inven_carry_okay(i_ptr))
			{
				msg_format("You have no room in your backpack for %s.", o_name);

				msg_format("%s falls to the dungeon floor.", o_name);

				floor_carry(y, x, i_ptr);
			}

			/* Give it to the player */
			else
			{
				int item_new;

				/* Give it to the player */
				item_new = inven_carry(i_ptr);

				/* Message */
				msg_format("You have burgled %s (%c).",
			           o_name, index_to_label(item_new));
			}
		}

		/*squelch the item, unless artifact*/
		else if (artifact_p(i_ptr))
		{
			/* Mark the object as indestructible */
			i_ptr->discount = INSCRIP_INDESTRUCTIBLE;

			/* Update the name */
			object_desc(o_name, sizeof(o_name), i_ptr, ODESC_BASE);

			/* Message */
			msg_format("You cannot squelch %s.", o_name);

			/* Now Check if the pack is too full */
			if (!inven_carry_okay(i_ptr))
			{
				msg_format("You have no room in your backpack for %s.", o_name);

				msg_format("%s falls the dungeon floor.", o_name);

				floor_carry(y, x, i_ptr);
			}

			/* Give it to the player */
			else
			{
				int item_new;

				/* Give it to the player */
				item_new = inven_carry(i_ptr);

				/* Message */
				msg_format("You have burgled %s (%c).",
			           o_name, index_to_label(item_new));
			}


		}

		/*squelch it*/
		else
		{

			/* At least let the player know they stole something */
			msg_format("You have burgled %s.{squelched}", o_name);

			/* Delete the object */
			object_wipe(i_ptr);

		}
	}

	/* Reset the object level */
	object_level = effective_depth(p_ptr->depth);

	/* Update monster recall window */
	if (p_ptr->monster_race_idx == m_ptr->r_idx)
	{
		/* Window stuff */
		p_ptr->redraw |= (PR_MONSTER);
	}

	return;
}



/*
 * Returns TRUE if an object is a throwing weapon and can be put in the quiver
 */
bool is_throwing_weapon(const object_type *o_ptr)
{
	u32b f1, f2, f3, fn;

	object_flags(o_ptr, &f1, &f2, &f3, &fn);

	if (f3 & (TR3_THROWING)) return (TRUE);

	return (FALSE);
}


/*
 * Mark an object's history
 */
void object_history(object_type *o_ptr, byte origin, s16b r_idx)
{
	o_ptr->origin_nature = origin;

	/* Paranoia */
	o_ptr->origin_dlvl = 0;
	o_ptr->origin_r_idx = 0;
	o_ptr->origin_m_name = 0;

	switch (origin)
	{
		case ORIGIN_DROP_KNOWN:
		{
			monster_race *r_ptr = &r_info[r_idx];

			/* Race */
			o_ptr->origin_r_idx = r_idx;

			/* Special case: player ghosts */
			if (r_ptr->flags2 & (RF2_PLAYER_GHOST))
			{
				/* Format the ghost name */
				char *name = player_ghost_name;

				/* Store the name */
				o_ptr->origin_m_name = quark_add(name);
			}

			/* Fall through */
		}
		case ORIGIN_ACQUIRE:
		case ORIGIN_DROP_UNKNOWN:
		case ORIGIN_FLOOR:
	  	case ORIGIN_CHEST:
		{
			o_ptr->origin_dlvl = p_ptr->depth;
			break;
		}
	}
}


/* The possible actions */

#define KEEP_O		1
#define KEEP_J		2
#define MIX		3

/*
 * Try to stack item histories
 */
void stack_histories(object_type *o_ptr, const object_type *j_ptr)
{
	int action = MIX;

	/* Histories are identical anyway */
	if ((o_ptr->origin_nature == j_ptr->origin_nature) &&
		 (o_ptr->origin_dlvl == j_ptr->origin_dlvl) &&
		 (o_ptr->origin_r_idx == j_ptr->origin_r_idx) &&
		 (o_ptr->origin_m_name == j_ptr->origin_m_name))

	{
		action = KEEP_O;
	}

	/* Do it */
	switch (action)
	{
		case (KEEP_O):
		{
			/* Nothing to do */
			break;
		}
		case (KEEP_J):
		{
			/* Copy over the second object's history */
			o_ptr->origin_nature = j_ptr->origin_nature;
			o_ptr->origin_dlvl = j_ptr->origin_dlvl;
			o_ptr->origin_r_idx = j_ptr->origin_r_idx;
			o_ptr->origin_m_name = j_ptr->origin_m_name;
			break;
		}
		case (MIX): default:
		{
			/* Lose object history */
			o_ptr->origin_nature = ORIGIN_MIXED;
			o_ptr->origin_dlvl = 0;
			o_ptr->origin_r_idx = 0;
			o_ptr->origin_m_name = 0;
			break;
		}
	}
}


/* Pseudo flag */
#define RBASE (TR2_RES_FIRE | TR2_RES_COLD | TR2_RES_ELEC | TR2_RES_ACID)

/* The amount of flag fields plus 1 */
#define MAX_GROUPS 5

/*
 * Create a string describing (some of) the known flags of the given object
 * If only_random_powers is TRUE the string will hold only a representation
 * of the random powers of ego-items
 */
void format_object_flags(const object_type *o_ptr, char buf[], int max, bool only_random_powers)
{
	u16b i;

	u32b f1 = 0, f2 = 0, f3 = 0, native = 0;

	/* It's easier to handle flags in arrays. See later */
	u32b flags[MAX_GROUPS];

	char *end;

	/*
	 * Object flags and their names
	 */
	static struct
	{
		u32b flag;
		byte group;	/* The field (1 for flags1, 2 for flags2, 3 for flags3 and 4 for native) */
		cptr name;
	} flag_info[] =
	{
		{TR2_IM_ACID,		2,	"ImAcid"},
		{TR2_IM_ELEC,		2,	"ImElec"},
		{TR2_IM_FIRE,		2,	"ImFire"},
		{TR2_IM_COLD,		2,	"ImCold"},
		{TR2_IM_POIS,		2,	"ImPois"},
		{RBASE,			2,	"RBase"},
		{TR2_RES_ACID,		2,	"RAcid"},
		{TR2_RES_ELEC,		2,	"RElec"},
		{TR2_RES_FIRE,		2,	"RFire"},
		{TR2_RES_COLD,		2,	"RCold"},
		{TR2_RES_POIS,		2,	"RPois"},
		{TR2_RES_FEAR,		2,	"RFear"},
		{TR2_RES_LIGHT,		2,	"RLite"},
		{TR2_RES_DARK,		2,	"RDark"},
		{TR2_RES_BLIND,		2,	"RBlind"},
		{TR2_RES_CONFU,		2,	"RConfu"},
		{TR2_RES_SOUND,		2,	"RSound"},
		{TR2_RES_SHARD,		2,	"RShard"},
		{TR2_RES_NEXUS,		2,	"RNexus"},
		{TR2_RES_NETHR,		2,	"RNethr"},
		{TR2_RES_CHAOS,		2,	"RChaos"},
		{TR2_RES_DISEN,		2,	"RDisen"},
		{TR3_SLOW_DIGEST,	3,	"S.Dig"},
		{TR3_FEATHER,		3,	"Feath"},
		{TR3_LIGHT,		3,	"PLite"},
		{TR3_REGEN,		3,	"Regen"},
		{TR3_TELEPATHY,		3,	"Telep"},
		{TR3_SEE_INVIS,		3,	"Invis"},
		{TR3_FREE_ACT,		3,	"FrAct"},
		{TR3_HOLD_LIFE,		3,	"HLife"},
		{TR1_STR,		1,	"STR"},
		{TR1_INT,		1,	"INT"},
		{TR1_WIS,		1,	"WIS"},
		{TR1_DEX,		1,	"DEX"},
		{TR1_CON,		1,	"CON"},
		{TR1_CHR,		1,	"CHR"},
		{TR2_SUST_STR,		2,	"SustSTR"},
		{TR2_SUST_INT,		2,	"SustINT"},
		{TR2_SUST_WIS,		2,	"SustWIS"},
		{TR2_SUST_DEX,		2,	"SustDEX"},
		{TR2_SUST_CON,		2,	"SustCON"},
		{TR2_SUST_CHR,		2,	"SustCHR"},
		{TR1_BRAND_ACID,	1,	"BrandAcid"},
		{TR1_BRAND_ELEC,	1,	"BrandElec"},
		{TR1_BRAND_FIRE,	1,	"BrandFire"},
		{TR1_BRAND_COLD,	1,	"BrandCold"},
		{TR1_BRAND_POIS,	1,	"BrandPois"},
		{TR1_SLAY_ANIMAL,	1,	"SlayAnimal"},
		{TR1_SLAY_EVIL,		1,	"SlayEvil"},
		{TR1_SLAY_UNDEAD,	1,	"SlayUndead"},
		{TR1_SLAY_DEMON,	1,	"SlayDemon"},
		{TR1_SLAY_ORC,		1,	"SlayOrc"},
		{TR1_SLAY_TROLL,	1,	"SlayTroll"},
		{TR1_SLAY_GIANT,	1,	"SlayGiant"},
		{TR1_SLAY_DRAGON,	1,	"SlayDragon"},
		{TR1_KILL_DRAGON,	1,	"KillDragon"},
		{TR1_KILL_DEMON,	1,	"KillDemon"},
		{TR1_KILL_UNDEAD,	1,	"KillUndead"},
		{TN1_NATIVE_LAVA,	4,	"NLava"},
		{TN1_NATIVE_ICE,	4,	"NIce"},
		{TN1_NATIVE_OIL,	4,	"NOil"},
		{TN1_NATIVE_FIRE,	4,	"NFire"},
		{TN1_NATIVE_SAND,	4,	"NSand"},
		{TN1_NATIVE_FOREST,	4,	"NForest"},
		{TN1_NATIVE_WATER,	4,	"NWater"},
		{TN1_NATIVE_ACID,	4,	"NAcid"},
		{TN1_NATIVE_MUD,	4,	"NMud"},
	};

	/* Get the known flags */
	object_flags_known(o_ptr, &f1, &f2, &f3, &native);

	/* Remove all the fixed flags if requested */
	if (only_random_powers)
	{
		/* Get the object kind */
		object_kind *k_ptr = &k_info[o_ptr->k_idx];

		/* Remove the flags */
		f1 &= ~(k_ptr->k_flags1);
		f2 &= ~(k_ptr->k_flags2);
		f3 &= ~(k_ptr->k_flags3);
		native &= ~(k_ptr->k_native);

		/* It's an artifact */
		if (o_ptr->art_num)
		{
			/* Get the artifact template */
			artifact_type *a_ptr = &a_info[o_ptr->art_num];

			/* Remove the flags */
			f1 &= ~(a_ptr->a_flags1);
			f2 &= ~(a_ptr->a_flags2);
			f3 &= ~(a_ptr->a_flags3);
			native &= ~(a_ptr->a_native);
		}

		/* It's an ego-item */
		if (o_ptr->ego_num)
		{
			/* Get the ego-item template */
			ego_item_type *e_ptr = &e_info[o_ptr->ego_num];

			/* Remove the flags */
			f1 &= ~(e_ptr->flags1);
			f2 &= ~(e_ptr->flags2);
			f3 &= ~(e_ptr->flags3);
			native &= ~(e_ptr->e_native);
		}
	}

	/* Make an array of flags with the individual flags */
	flags[0] = 0;
	flags[1] = f1;
	flags[2] = f2;
	flags[3] = f3;
	flags[4] = native;


	/* Start with an empty string */
	buf[0] = '\0';
	end = NULL;

	/* Scan the flags */
	for (i = 0; i < N_ELEMENTS(flag_info); i++)
	{
		/* Check presence of the flag */
		if ((flags[flag_info[i].group] & flag_info[i].flag) ==
			flag_info[i].flag)
		{
			/* Append a space if it's not the first flag we found */
			if (end != NULL)
			{
				end = my_fast_strcat(buf, end, " ", max);
			}

			/* Append the flag name */
			end = my_fast_strcat(buf, end, flag_info[i].name, max);

			/* Special cases in flags2 */
			if (flag_info[i].group == 2)
			{
				/* Analyze flag */
				switch (flag_info[i].flag)
				{
					/* Immunities remove the respective resistances */
					case TR2_IM_ACID: flags[2] &= ~(TR2_RES_ACID); break;
					case TR2_IM_FIRE: flags[2] &= ~(TR2_RES_FIRE); break;
					case TR2_IM_COLD: flags[2] &= ~(TR2_RES_COLD); break;
					case TR2_IM_ELEC: flags[2] &= ~(TR2_RES_ELEC); break;
					case TR2_IM_POIS: flags[2] &= ~(TR2_RES_POIS); break;
					/* Special flag, RBASE, remove individual resistances */
					case RBASE: flags[2] &= ~(RBASE); break;
				}
			}
		}
	}
}


/*
 * Put a copy of "src" into "dest". Expand a replaces some special patterns found in "src"
 * with short descriptions of the known object flags. These patterns are:
 * :all:
 * 	Put all the known flags
 * :random:
 *	Put only the known random powers of ego-items
 */
void expand_inscription(const object_type *o_ptr, const char *src, char dest[], int max)
{
	int i = 0, j = 0;

	/* Save a space for the trailing null char */
	if (max > 0) --max;

	/* Scan the source inscription */
	while (src[i] && (j < max))
	{
		/* Regular characters */
		if (src[i] != ':')
		{
			/* Just copy them */
			dest[j++] = src[i++];
		}
		/* Found the start of a pattern */
		else
		{
			char temp[200];
			/* The supported patterns */
			const char *pattern_list[] = {":all:", ":random:"};
			/* Info of each pattern */
			bool mode_list[] = {FALSE, TRUE};
			int found = -1;
			u16b k;

			/* Scan the pattern list */
			for (k = 0; (k < N_ELEMENTS(pattern_list)) && (found == -1); k++)
			{
				/* Is it this pattern? */
				if (prefix(src + i, pattern_list[k]))
				{
					/* Yes */
					found = k;
				}
			}

			/* Found a pattern match */
			if (found != -1)
			{
				/* Get the flag text. Note use of the mode list */
				format_object_flags(o_ptr, temp, sizeof(temp), mode_list[found]);

				/* Go to the first character */
				k = 0;

				/* Copy the flag text to the ouput buffer */
				while (temp[k] && (j < max))
				{
					dest[j++] = temp[k++];
				}

				/* Skip the pattern */
				i += strlen(pattern_list[found]);
			}
			/* Unknown patter */
			else
			{
				/* Just copy */
				dest[j++] = src[i++];
			}
		}
	}

	/* Append the trailing null character */
	dest[j] = '\0';
}


